<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trading Journal - 365 Day Year</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        body { min-height: 100vh; background: #08080c; font-family: system-ui, -apple-system, sans-serif; color: #fff; padding: 8px; overflow: hidden; }
        button { font-family: inherit; cursor: pointer; border: none; background: none; color: inherit; }
        
        .container { display: flex; flex-direction: column; height: calc(100vh - 16px); gap: 6px; position: relative; z-index: 10; }
        
        .header { display: flex; justify-content: space-between; align-items: center; }
        .title { font-size: 18px; font-weight: 600; }
        .subtitle { font-size: 10px; color: #555; }
        .header-right { display: flex; gap: 4px; align-items: center; }
        
        .hamburger-btn { width: 32px; height: 32px; border-radius: 6px; background: rgba(12,12,18,0.95); border: 1px solid rgba(255,255,255,0.08); color: #888; display: flex; align-items: center; justify-content: center; font-size: 14px; }
        .hamburger-btn.active { color: #22c55e; border-color: rgba(34,197,94,0.3); }
        
        .hamburger-menu { position: absolute; top: 45px; left: 8px; background: linear-gradient(180deg,#1a1a1e,#121215); border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); padding: 6px; min-width: 160px; z-index: 100; display: none; }
        .hamburger-menu.open { display: block; }
        .menu-item { width: 100%; padding: 10px 12px; border-radius: 6px; background: transparent; border: none; color: #ccc; font-size: 13px; text-align: left; display: flex; align-items: center; gap: 8px; }
        .menu-item:hover { background: rgba(255,255,255,0.05); }
        .menu-item .icon { font-size: 14px; }
        
        .clock-btn { font-family: monospace; font-size: 12px; font-weight: 600; background: rgba(12,12,18,0.95); border: 1px solid rgba(255,255,255,0.08); border-radius: 6px; padding: 6px 8px; position: relative; user-select: none; }
        .clock-btn.active { color: #22c55e; border-color: rgba(34,197,94,0.3); }
        .clock-btn.inactive { color: #666; }
        .clock-strike { position: absolute; top: 50%; left: 4px; right: 4px; height: 1.5px; background: #ef4444; transform: rotate(-10deg); }
        
        .refresh-btn { width: 32px; height: 32px; border-radius: 6px; background: rgba(12,12,18,0.95); border: 1px solid rgba(255,255,255,0.08); color: #666; display: flex; align-items: center; justify-content: center; font-size: 14px; }
        
        .stats { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap: 4px; margin-top: 4px; }
        .stat { padding: 6px 8px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 6px; text-align: center; }
        .stat-label { font-size: 8px; color: #555; text-transform: uppercase; margin-bottom: 1px; }
        .stat-value { font-family: monospace; font-size: 12px; font-weight: 600; }
        .stat-value .dim { color: #444; }
        .green { color: #22c55e; }
        .red { color: #ef4444; }
        
        .calendar-wrap { flex: 1; border-radius: 10px; background: rgba(12,12,18,0.95); border: 1px solid rgba(255,255,255,0.06); padding: 6px; overflow: hidden; display: flex; flex-direction: column; }
        .calendar-slider { display: flex; width: 300%; transition: transform 0.3s ease; flex: 1; min-height: 0; }
        .calendar-page { width: 33.333%; display: flex; flex-direction: column; gap: 4px; overflow: hidden; flex-shrink: 0; }
        .calendar-grid { display: flex; flex-direction: column; gap: 4px; flex: 1; min-height: 0; }
        .calendar-row { display: flex; gap: 4px; flex: 1; min-height: 0; }
        
        .menu-prediction { padding: 10px; border-radius: 8px; margin-bottom: 10px; }
        .menu-prediction.aggressive { background: linear-gradient(135deg, rgba(34,197,94,0.2), rgba(34,197,94,0.05)); border: 1px solid rgba(34,197,94,0.4); }
        .menu-prediction.cautious { background: linear-gradient(135deg, rgba(234,179,8,0.2), rgba(234,179,8,0.05)); border: 1px solid rgba(234,179,8,0.4); }
        .menu-prediction.defensive { background: linear-gradient(135deg, rgba(239,68,68,0.2), rgba(239,68,68,0.05)); border: 1px solid rgba(239,68,68,0.4); }
        .menu-prediction.neutral { background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.08); }
        .menu-prediction-header { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
        .menu-prediction-emoji { font-size: 16px; }
        .menu-prediction-label { font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        .menu-prediction-label.green { color: #22c55e; }
        .menu-prediction-label.yellow { color: #eab308; }
        .menu-prediction-label.red { color: #ef4444; }
        .menu-prediction-detail { font-size: 10px; color: #888; }
        .menu-prediction-ratio { font-size: 11px; font-weight: 600; font-family: monospace; margin-top: 4px; }
        .menu-best-times { margin-top: 12px; padding: 10px; background: rgba(59,130,246,0.08); border: 1px solid rgba(59,130,246,0.2); border-radius: 8px; }
        .menu-best-times-header { font-size: 10px; font-weight: 600; color: #3b82f6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .menu-best-times-note { font-size: 10px; color: #666; font-style: italic; }
        .zone-row { display: flex; align-items: center; gap: 8px; padding: 6px 8px; font-size: 11px; border-radius: 4px; margin-bottom: 4px; }
        .zone-row:last-child { margin-bottom: 0; }
        .zone-row.hit { background: rgba(34,197,94,0.1); }
        .zone-row.miss { background: rgba(255,255,255,0.02); opacity: 0.5; }
        .zone-check { font-size: 12px; width: 16px; }
        .zone-row.hit .zone-check { color: #22c55e; }
        .zone-row.miss .zone-check { color: #ef4444; }
        .zone-rank { color: #3b82f6; font-weight: 700; width: 20px; }
        .zone-time { color: #888; font-family: monospace; font-size: 10px; width: 95px; }
        .zone-trades { flex: 1; font-size: 10px; font-weight: 500; }
        .zone-trades.dim { color: #444; }
        .menu-trades-header { font-size: 11px; font-weight: 600; color: #888; margin-top: 12px; margin-bottom: 6px; }
        .menu-trades-list { border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; }
        .menu-trade-item { display: flex; align-items: center; gap: 6px; padding: 6px 0; font-size: 11px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .menu-trade-item.allowed { }
        .menu-trade-item.not-allowed { opacity: 0.5; }
        .trade-status { font-size: 12px; min-width: 16px; }
        .trade-ticker { color: #fff; font-weight: 600; min-width: 50px; }
        .trade-time { color: #888; font-size: 10px; flex: 1; }
        .trade-rank { color: #3b82f6; font-size: 10px; min-width: 20px; }
        .trade-r { font-weight: 600; font-family: monospace; }
        .menu-trade-item.allowed .trade-status { color: #22c55e; }
        .menu-trade-item.not-allowed .trade-status { color: #ef4444; }
        .menu-trades-note { font-size: 9px; color: #666; margin-top: 6px; text-align: center; }
        
        .splash-modal { background: #1a1a1a; border-radius: 16px; padding: 24px; text-align: center; max-width: 320px; width: 90%; border: 2px solid rgba(255,255,255,0.1); }
        .splash-modal.aggressive { border-color: rgba(34,197,94,0.5); background: linear-gradient(180deg, rgba(34,197,94,0.15) 0%, #1a1a1a 50%); }
        .splash-modal.cautious { border-color: rgba(234,179,8,0.5); background: linear-gradient(180deg, rgba(234,179,8,0.15) 0%, #1a1a1a 50%); }
        .splash-modal.defensive { border-color: rgba(239,68,68,0.5); background: linear-gradient(180deg, rgba(239,68,68,0.15) 0%, #1a1a1a 50%); }
        .splash-header { font-size: 28px; font-weight: 800; margin-bottom: 8px; letter-spacing: 1px; }
        .splash-header.green { color: #22c55e; }
        .splash-header.yellow { color: #eab308; }
        .splash-header.red { color: #ef4444; }
        .splash-subtext { font-size: 14px; color: #888; margin-bottom: 12px; }
        .splash-advice { font-size: 16px; font-weight: 600; color: #fff; margin-bottom: 20px; line-height: 1.4; }
        .splash-times { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 24px; }
        .splash-times-label { width: 100%; font-size: 12px; color: #3b82f6; font-weight: 600; margin-bottom: 4px; }
        .splash-time-box { background: rgba(59,130,246,0.15); border: 1px solid rgba(59,130,246,0.4); border-radius: 10px; padding: 10px 14px; min-width: 85px; }
        .splash-time-rank { font-size: 12px; font-weight: 700; color: #3b82f6; margin-bottom: 4px; }
        .splash-time-value { font-size: 13px; font-weight: 700; color: #fff; }
        .splash-time-to { font-size: 10px; color: #888; }
        .splash-time-pct { font-size: 11px; color: #22c55e; margin-top: 4px; font-weight: 600; }
        .splash-btn { width: 100%; padding: 14px; border-radius: 10px; border: none; background: linear-gradient(135deg, #3b82f6, #2563eb); color: #fff; font-size: 16px; font-weight: 700; cursor: pointer; }
        .splash-btn:active { transform: scale(0.98); }
        
        .top3-times { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(59,130,246,0.05)); border: 1px solid rgba(59,130,246,0.3); border-radius: 8px; padding: 8px 10px; margin-bottom: 6px; }
        .top3-header { font-size: 10px; font-weight: 600; color: #3b82f6; margin-bottom: 6px; }
        .top3-list { display: flex; gap: 6px; }
        .top3-item { flex: 1; background: rgba(0,0,0,0.2); border-radius: 6px; padding: 6px; text-align: center; cursor: pointer; }
        .top3-item:hover { background: rgba(59,130,246,0.2); }
        .top3-rank { font-size: 10px; font-weight: 700; color: #3b82f6; }
        .top3-time { font-size: 11px; font-weight: 600; color: #fff; margin-top: 2px; }
        .top3-to { font-size: 9px; color: #888; }
        .top3-winrate { font-size: 9px; color: #22c55e; margin-top: 2px; }
        
        .calendar-toggles { display: flex; gap: 6px; margin-bottom: 4px; }
        .calendar-toggle { flex: 1; padding: 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: #888; font-size: 11px; font-weight: 500; }
        .calendar-toggle.active { border-color: rgba(34,197,94,0.5); background: rgba(34,197,94,0.1); color: #22c55e; }
        .week-nav { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; gap: 8px; }
        .week-nav-btn { padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05); color: #888; font-size: 11px; font-weight: 500; }
        .week-nav-btn:active { background: rgba(255,255,255,0.1); }
        .week-nav-label { font-size: 12px; color: #888; font-weight: 600; }
        
        .graph-page { padding: 6px; justify-content: flex-start; }
        .graph-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap; gap: 8px; }
        .graph-title { font-size: 14px; font-weight: 600; color: #fff; }
        .graph-trade-count { font-size: 12px; color: #888; font-weight: 600; }
        .graph-controls { display: flex; align-items: center; gap: 8px; }
        .graph-ctrl-btn { width: 32px; height: 32px; border-radius: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; font-size: 18px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .graph-ctrl-btn:active { background: rgba(255,255,255,0.2); }
        .graph-zoom-level { font-size: 11px; color: #888; min-width: 40px; text-align: center; }
        .graph-container { position: relative; display: flex; align-items: center; gap: 4px; }
        .graph-scroll-wrap { flex: 1; overflow-x: auto; overflow-y: hidden; border-radius: 8px; background: rgba(0,0,0,0.2); -webkit-overflow-scrolling: touch; }
        .graph-scroll-wrap::-webkit-scrollbar { height: 6px; }
        .graph-scroll-wrap::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 3px; }
        .graph-scroll-wrap::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        .graph-arrow { width: 28px; height: 60px; border-radius: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15); color: #fff; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .graph-arrow:active { background: rgba(255,255,255,0.2); }
        #graphCanvas { display: block; height: 350px; }
        .graph-toggle { flex: 1; padding: 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: #888; font-size: 11px; font-weight: 500; }
        .graph-toggle.active { border-color: rgba(34,197,94,0.5); background: rgba(34,197,94,0.1); color: #22c55e; }
        .win-rate-row { display: flex; gap: 3px; margin-bottom: 4px; overflow-x: auto; padding-bottom: 2px; }
        .win-rate-item { flex: 0 0 auto; padding: 3px 6px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); border-radius: 4px; text-align: center; min-width: 42px; }
        .win-rate-time { font-size: 8px; color: #666; }
        .win-rate-pct { font-size: 10px; font-weight: 600; }
        .win-rate-pct.high { color: #22c55e; }
        .win-rate-pct.mid { color: #eab308; }
        .win-rate-pct.low { color: #ef4444; }
        /* Canvas styles moved to graph-scroll-wrap */
        
        .day-box { flex: 1; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.02); position: relative; }
        .day-box.has-trades { background: linear-gradient(135deg,rgba(34,197,94,0.1),rgba(34,197,94,0.02)); border-color: rgba(34,197,94,0.2); }
        .day-box.negative { background: linear-gradient(135deg,rgba(239,68,68,0.15),rgba(239,68,68,0.05)); border-color: rgba(239,68,68,0.3); }
        .day-box.sitout { background: #2a2a2a; border-color: rgba(100,100,100,0.5); }
        .day-box.week { background: linear-gradient(135deg,rgba(34,197,94,0.2),rgba(34,197,94,0.05)); border-color: rgba(34,197,94,0.4); }
        .day-box.week.negative { background: linear-gradient(135deg,rgba(239,68,68,0.2),rgba(239,68,68,0.05)); border-color: rgba(239,68,68,0.4); }
        .day-box.today { box-shadow: 0 0 0 2px #22c55e; }
        .sitout-label { font-size: 10px; color: #666; font-weight: 600; }
        .sitout-actual { font-size: 14px; }
        .day-pct { font-size: 14px; font-weight: 700; }
        .temp-badge { position: absolute; top: 1px; right: 1px; font-size: 8px; line-height: 1; }
        .temp-badge.hot { filter: drop-shadow(0 0 2px rgba(255,100,0,0.5)); }
        .temp-badge.warm { filter: drop-shadow(0 0 2px rgba(255,200,0,0.4)); }
        .temp-badge.cold { filter: drop-shadow(0 0 2px rgba(100,150,255,0.5)); }
        .pred-badge { position: absolute; top: 1px; left: 1px; font-size: 7px; line-height: 1; opacity: 0.6; }
        .day-label { font-size: 8px; color: #555; margin-bottom: 1px; }
        .day-label.week { font-weight: 600; color: #888; letter-spacing: 0.5px; }
        .day-count { font-family: monospace; font-size: 14px; font-weight: 700; }
        .day-count .slash { font-size: 10px; color: #444; }
        .day-count .total { font-size: 10px; color: #555; }
        .day-r { font-family: monospace; font-size: 9px; font-weight: 600; }
        .day-ratio { font-family: monospace; font-size: 9px; font-weight: 600; display: block; }
        .day-ratio .ratio-slash { color: #444; margin: 0 1px; }
        .day-ratio .yellow { color: #eab308; }
        .week-r { font-family: monospace; font-size: 11px; font-weight: 700; }
        .week-money { font-family: monospace; font-size: 9px; font-weight: 600; }
        
        .dots { display: flex; justify-content: center; gap: 6px; padding: 4px 0; }
        .dot { width: 6px; height: 6px; border-radius: 3px; background: rgba(255,255,255,0.2); transition: all 0.2s; }
        .dot.active { width: 18px; background: #22c55e; }
        
        .balance-row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 4px; }
        .balance-box { padding: 6px 8px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 6px; display: flex; justify-content: space-between; align-items: center; }
        .balance-label { font-size: 8px; color: #555; text-transform: uppercase; }
        .balance-value { font-family: monospace; font-size: 11px; font-weight: 600; }
        
        .progress-section { margin-top: 4px; padding: 6px 8px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 6px; }
        .progress-header { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .progress-label { font-size: 8px; color: #555; text-transform: uppercase; }
        .progress-value { font-size: 10px; color: #888; font-weight: 500; }
        .progress-bar-wrap { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #22c55e, #4ade80); border-radius: 3px; transition: width 0.3s ease; width: 0%; }
        
        .goals-row { display: grid; grid-template-columns: 1fr 1fr 0.5fr; gap: 4px; margin-top: 4px; }
        .goal-box { padding: 6px 8px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 6px; text-align: center; }
        .goal-label { font-size: 8px; color: #555; text-transform: uppercase; margin-bottom: 2px; }
        .goal-progress { font-family: monospace; font-size: 11px; font-weight: 600; }
        .goal-current { color: #22c55e; }
        .goal-current.behind { color: #ef4444; }
        .goal-dim { color: #444; }
        .goal-target { color: #888; }
        .goal-icon { font-size: 14px; }
        .goal-box.achieved { border-color: rgba(34,197,94,0.4); background: rgba(34,197,94,0.1); }
        
        .tags-wrap { display: flex; flex-wrap: wrap; gap: 6px; }
        .tag-btn { padding: 6px 10px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.03); color: #888; font-size: 11px; transition: all 0.2s; }
        .tag-btn.active { border-color: rgba(34,197,94,0.5); background: rgba(34,197,94,0.15); color: #22c55e; }
        
        .r-btns { display: flex; gap: 8px; }
        .r-btn { flex: 1; padding: 12px 8px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.03); font-size: 14px; font-weight: 700; font-family: monospace; transition: all 0.2s; }
        .r-btn.positive { color: #22c55e; }
        .r-btn.negative { color: #ef4444; }
        .r-btn.positive.active { border-color: #22c55e; background: rgba(34,197,94,0.2); }
        .r-btn.negative.active { border-color: #ef4444; background: rgba(239,68,68,0.2); }
        
        .review-content { font-size: 13px; line-height: 1.6; }
        .review-section { margin-bottom: 16px; }
        .review-title { font-size: 14px; font-weight: 600; color: #22c55e; margin-bottom: 8px; }
        .review-stat { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .review-stat-label { color: #888; }
        .review-stat-value { font-family: monospace; font-weight: 600; }
        .review-tags { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
        .review-tag { padding: 4px 8px; border-radius: 12px; background: rgba(255,255,255,0.05); font-size: 11px; color: #888; }
        .review-tag .count { color: #22c55e; margin-left: 4px; }
        
        /* Modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); backdrop-filter: blur(12px); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 16px; }
        .modal-overlay.hidden { display: none; }
        .modal { background: linear-gradient(180deg,#141418,#0c0c10); border-radius: 16px; border: 1px solid rgba(255,255,255,0.08); width: 100%; max-width: 360px; max-height: 80vh; overflow-y: auto; padding: 20px; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .modal-title { font-size: 18px; font-weight: 600; }
        .modal-close { width: 28px; height: 28px; border-radius: 6px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); color: #888; font-size: 16px; display: flex; align-items: center; justify-content: center; }
        .modal-back { padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.08); color: #888; font-size: 12px; }
        
        .menu-btn { width: 100%; padding: 14px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: #fff; font-size: 14px; font-weight: 500; display: flex; align-items: center; gap: 10px; margin-bottom: 10px; text-align: left; }
        .menu-btn.green { border-color: rgba(34,197,94,0.3); background: rgba(34,197,94,0.08); color: #22c55e; }
        .menu-btn .icon { font-size: 18px; }
        
        .form-group { margin-bottom: 14px; }
        .form-label { display: block; font-size: 11px; color: #666; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
        .form-input, .form-select { width: 100%; padding: 10px 14px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.08); background: #1a1a1a; color: #fff; font-size: 14px; }
        .form-select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23888' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; }
        
        .type-btns { display: flex; gap: 6px; }
        .type-btn { flex: 1; padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: #888; font-size: 12px; text-align: center; }
        .type-btn.active { border-color: rgba(34,197,94,0.5); background: rgba(34,197,94,0.1); color: #22c55e; }
        
        .submit-btn { width: 100%; padding: 12px 20px; border-radius: 10px; border: 1px solid rgba(34,197,94,0.3); background: rgba(34,197,94,0.08); color: #22c55e; font-size: 14px; font-weight: 500; }
        .submit-btn.secondary { border-color: rgba(59,130,246,0.3); background: rgba(59,130,246,0.08); color: #3b82f6; }
        .view-btns { display: flex; gap: 8px; margin-top: 12px; }
        .view-btns .submit-btn { flex: 1; font-size: 11px; padding: 10px 6px; }
        
        .trade-item { padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.06); border-left: 3px solid #22c55e; background: rgba(255,255,255,0.02); display: flex; align-items: center; margin-bottom: 6px; }
        .trade-item.setup { border-left-color: #444; opacity: 0.7; }
        .trade-item.best2-highlight { border: 2px solid rgba(59,130,246,0.7); background: rgba(59,130,246,0.15); border-left: 4px solid #3b82f6; }
        .trade-num { font-size: 10px; color: #555; font-weight: 600; margin-right: 10px; min-width: 22px; }
        .best2-badge { color: #3b82f6; margin-right: 4px; font-size: 12px; }
        .trade-info { flex: 1; }
        .trade-ticker { font-family: monospace; font-size: 14px; font-weight: 600; }
        .trade-time { font-size: 10px; color: #555; }
        .trade-r { font-family: monospace; font-size: 16px; font-weight: 700; margin-right: 10px; }
        .trade-winrate { font-size: 11px; font-weight: 700; padding: 3px 6px; border-radius: 4px; margin-right: 8px; min-width: 36px; text-align: center; }
        .trade-winrate.high { background: rgba(34,197,94,0.2); color: #22c55e; }
        .trade-winrate.mid { background: rgba(234,179,8,0.2); color: #eab308; }
        .trade-winrate.low { background: rgba(239,68,68,0.2); color: #ef4444; }
        .trade-winrate.none { background: rgba(255,255,255,0.05); color: #555; }
        .zone-rank { font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.1); color: #888; margin-right: 6px; }
        .zone-rank.top3 { background: rgba(59,130,246,0.2); color: #3b82f6; }
        .zone-rank.none { color: #555; }
        .trade-btn { width: 28px; height: 28px; border-radius: 5px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: #888; font-size: 12px; margin-left: 6px; display: flex; align-items: center; justify-content: center; }
        
        .empty-state { text-align: center; padding: 24px; color: #555; }
        .empty-icon { font-size: 28px; margin-bottom: 8px; }
        
        .week-section { margin-bottom: 16px; }
        .week-section-title { font-size: 11px; color: #555; text-transform: uppercase; margin-bottom: 10px; }
        .week-best-times-list { display: flex; flex-direction: column; gap: 6px; }
        .week-best-time-item { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: rgba(59,130,246,0.1); border: 1px solid rgba(59,130,246,0.3); border-radius: 6px; }
        .week-best-time-rank { font-size: 12px; font-weight: 700; color: #3b82f6; min-width: 24px; }
        .week-best-time-time { font-family: monospace; font-size: 13px; font-weight: 600; color: #fff; flex: 1; }
        .week-best-time-stats { font-size: 10px; color: #888; }
        .week-no-data { font-size: 12px; color: #666; font-style: italic; padding: 10px; text-align: center; }
        .week-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .week-stat { padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); text-align: center; }
        .week-stat.full { grid-column: span 2; padding: 12px; }
        .week-stat.positive { border-color: rgba(34,197,94,0.3); background: rgba(34,197,94,0.05); }
        .week-stat.negative { border-color: rgba(239,68,68,0.3); background: rgba(239,68,68,0.05); }
        .week-stat-value { font-family: monospace; font-size: 18px; font-weight: 700; }
        .week-stat-value.big { font-size: 20px; }
        .week-stat-label { font-size: 9px; color: #555; }
        
        .clear-btn { width: 100%; padding: 12px 16px; border-radius: 8px; border: 1px solid rgba(239,68,68,0.3); background: rgba(239,68,68,0.08); color: #ef4444; font-size: 13px; font-weight: 500; margin-bottom: 8px; }
        .cancel-btn { width: 100%; padding: 12px 16px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: #888; font-size: 13px; font-weight: 500; }
        
        .balance-presets { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px; }
        .balance-preset { padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: #888; font-size: 11px; }
        
        .photo-btns { display: flex; gap: 6px; margin-bottom: 8px; }
        .photo-btn { flex: 1; padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: #888; font-size: 12px; text-align: center; }
        .photo-preview { display: none; }
        .photo-preview.has-photo { display: block; margin-top: 8px; position: relative; }
        .photo-preview img { width: 100%; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); }
        .photo-remove { position: absolute; top: 8px; right: 8px; width: 28px; height: 28px; border-radius: 50%; background: rgba(0,0,0,0.7); border: 1px solid rgba(255,255,255,0.2); color: #fff; font-size: 14px; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        
        .modal-text { color: #666; margin-bottom: 16px; font-size: 13px; }
        
        /* Analytics Page */
        .analytics-page { padding: 8px; overflow-y: auto; overflow-x: hidden; }
        .analytics-section { margin-bottom: 16px; flex-shrink: 0; }
        .analytics-title { font-size: 12px; color: #888; text-transform: uppercase; margin-bottom: 10px; font-weight: 600; letter-spacing: 0.5px; display: flex; align-items: center; gap: 6px; }
        
        /* Day of Week Heatmap */
        .dow-heatmap { display: flex; gap: 6px; }
        .dow-item { flex: 1; padding: 10px 6px; border-radius: 8px; text-align: center; border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); transition: all 0.3s; position: relative; overflow: hidden; }
        .dow-item::before { content: ''; position: absolute; inset: 0; opacity: 0; transition: opacity 0.3s; }
        .dow-item.hot { border-color: rgba(34,197,94,0.5); }
        .dow-item.hot::before { background: linear-gradient(135deg, rgba(34,197,94,0.25), rgba(34,197,94,0.05)); opacity: 1; }
        .dow-item.warm { border-color: rgba(34,197,94,0.3); }
        .dow-item.warm::before { background: linear-gradient(135deg, rgba(34,197,94,0.15), rgba(34,197,94,0.03)); opacity: 1; }
        .dow-item.cold { border-color: rgba(239,68,68,0.3); }
        .dow-item.cold::before { background: linear-gradient(135deg, rgba(239,68,68,0.15), rgba(239,68,68,0.03)); opacity: 1; }
        .dow-item.freezing { border-color: rgba(239,68,68,0.5); }
        .dow-item.freezing::before { background: linear-gradient(135deg, rgba(239,68,68,0.25), rgba(239,68,68,0.05)); opacity: 1; }
        .dow-item > * { position: relative; z-index: 1; }
        .dow-day { font-size: 11px; color: #888; font-weight: 700; letter-spacing: 0.5px; }
        .dow-r { font-family: monospace; font-size: 14px; font-weight: 700; margin-top: 4px; }
        .dow-trades { font-size: 9px; color: #555; margin-top: 3px; }
        .dow-winrate { font-size: 10px; font-weight: 600; margin-top: 2px; }
        .dow-badge { position: absolute; top: 4px; right: 4px; font-size: 10px; }
        
        /* Best/Worst Time Slots */
        .time-extremes { display: flex; gap: 8px; margin-top: 8px; }
        .time-extreme { flex: 1; padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); text-align: left; }
        .time-extreme.best { border-color: rgba(34,197,94,0.4); background: linear-gradient(135deg, rgba(34,197,94,0.1), rgba(34,197,94,0.02)); }
        .time-extreme.worst { border-color: rgba(239,68,68,0.4); background: linear-gradient(135deg, rgba(239,68,68,0.1), rgba(239,68,68,0.02)); }
        .time-extreme-label { font-size: 9px; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
        .time-extreme-time { font-size: 14px; font-weight: 700; font-family: monospace; }
        .time-extreme-stats { font-size: 10px; color: #888; margin-top: 4px; }
        .time-extreme-stats span { font-weight: 600; }
        
        /* 2-Trade Strategy Button */
        .two-trade-btn { width: 100%; margin-top: 10px; padding: 12px; background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(59,130,246,0.05)); border: 1px solid rgba(59,130,246,0.4); border-radius: 8px; text-align: left; }
        .two-trade-header { display: flex; justify-content: space-between; align-items: center; font-size: 11px; color: #3b82f6; font-weight: 600; margin-bottom: 6px; }
        .two-trade-summary { font-size: 12px; color: #ccc; }
        .two-trade-summary .green { color: #22c55e; font-weight: 600; }
        .two-trade-summary .time { font-family: monospace; font-weight: 700; color: #fff; }
        
        /* Time Ranking List */
        .time-rank-list { max-height: 300px; overflow-y: auto; }
        .time-rank-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-radius: 8px; margin-bottom: 6px; border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); }
        .time-rank-item.positive { border-left: 3px solid #22c55e; }
        .time-rank-item.negative { border-left: 3px solid #ef4444; }
        .time-rank-item.top3 { background: rgba(59,130,246,0.15); border: 1px solid rgba(59,130,246,0.4); border-left: 3px solid #3b82f6; }
        .time-rank-pos { font-size: 12px; font-weight: 700; color: #555; width: 20px; }
        .time-rank-pos.top3 { color: #3b82f6; }
        .time-rank-time { font-family: monospace; font-size: 13px; font-weight: 600; flex: 1; }
        .time-rank-r { font-family: monospace; font-size: 14px; font-weight: 700; }
        .time-rank-details { font-size: 10px; color: #666; }
        
        /* Calendar Heatmap */
        .calendar-heatmap { display: flex; flex-direction: column; gap: 3px; }
        .heatmap-row { display: flex; gap: 3px; align-items: center; }
        .heatmap-label { width: 28px; font-size: 9px; color: #555; text-align: right; padding-right: 6px; font-weight: 600; }
        .heatmap-cells { display: flex; gap: 3px; flex: 1; }
        .heatmap-cell { flex: 1; aspect-ratio: 1; border-radius: 3px; background: rgba(255,255,255,0.05); max-width: 18px; min-width: 10px; cursor: pointer; transition: transform 0.2s; position: relative; }
        .heatmap-cell:hover { transform: scale(1.3); z-index: 5; }
        .heatmap-cell.l4 { background: #dc2626; box-shadow: 0 0 4px rgba(220,38,38,0.4); }
        .heatmap-cell.l3 { background: rgba(239,68,68,0.7); }
        .heatmap-cell.l2 { background: rgba(239,68,68,0.45); }
        .heatmap-cell.l1 { background: rgba(239,68,68,0.25); }
        .heatmap-cell.w1 { background: rgba(34,197,94,0.25); }
        .heatmap-cell.w2 { background: rgba(34,197,94,0.45); }
        .heatmap-cell.w3 { background: rgba(34,197,94,0.7); }
        .heatmap-cell.w4 { background: #22c55e; box-shadow: 0 0 4px rgba(34,197,94,0.4); }
        .heatmap-legend { display: flex; gap: 6px; justify-content: center; margin-top: 8px; align-items: center; flex-wrap: wrap; }
        .heatmap-legend-item { display: flex; align-items: center; gap: 3px; font-size: 9px; color: #555; }
        .heatmap-legend-box { width: 12px; height: 12px; border-radius: 2px; }
        
        /* Scatter Plot */
        #scatterCanvas { width: 100%; height: 130px; background: rgba(0,0,0,0.2); border-radius: 8px; }
        .scatter-empty { text-align: center; padding: 40px; color: #444; font-size: 11px; background: rgba(0,0,0,0.2); border-radius: 8px; }
        
        /* Entry Distribution */
        .entry-dist-wrap { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; }
        .entry-dist { display: flex; gap: 4px; align-items: flex-end; height: 70px; }
        .entry-bar { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .entry-bar-stack { width: 100%; display: flex; flex-direction: column-reverse; }
        .entry-bar-win { background: linear-gradient(to top, rgba(34,197,94,0.8), rgba(34,197,94,0.6)); border-radius: 2px 2px 0 0; }
        .entry-bar-loss { background: linear-gradient(to top, rgba(239,68,68,0.8), rgba(239,68,68,0.6)); border-radius: 0 0 2px 2px; }
        .entry-bar-label { font-size: 8px; color: #666; margin-top: 4px; }
        .entry-dist-legend { display: flex; gap: 12px; justify-content: center; margin-top: 8px; }
        .entry-dist-legend-item { display: flex; align-items: center; gap: 4px; font-size: 9px; color: #666; }
        .entry-dist-legend-box { width: 10px; height: 10px; border-radius: 2px; }
        
        /* P&L Thermometer */
        .thermometer-wrap { display: flex; align-items: center; gap: 16px; padding: 12px; background: rgba(255,255,255,0.02); border-radius: 10px; border: 1px solid rgba(255,255,255,0.06); }
        .thermometer { width: 28px; height: 140px; background: linear-gradient(to top, #ef4444 0%, #ef4444 30%, #eab308 30%, #eab308 50%, #22c55e 50%, #22c55e 100%); border-radius: 14px; position: relative; overflow: hidden; border: 2px solid rgba(255,255,255,0.15); box-shadow: inset 0 0 10px rgba(0,0,0,0.3); }
        .thermometer-fill { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(8,8,12,0.85); transition: height 0.6s cubic-bezier(0.4, 0, 0.2, 1); }
        .thermometer-marker { position: absolute; left: -6px; right: -6px; height: 4px; background: #fff; border-radius: 2px; transition: bottom 0.6s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 0 8px rgba(255,255,255,0.6), 0 0 16px rgba(255,255,255,0.3); }
        .thermometer-info { flex: 1; }
        .thermometer-current { font-family: monospace; font-size: 32px; font-weight: 700; line-height: 1; }
        .thermometer-label { font-size: 10px; color: #555; text-transform: uppercase; margin-top: 2px; }
        .thermometer-target { font-size: 12px; color: #666; margin-top: 8px; }
        .thermometer-target span { color: #888; font-weight: 600; }
        .thermometer-status { font-size: 11px; font-weight: 600; margin-top: 10px; padding: 5px 10px; border-radius: 6px; display: inline-block; }
        .thermometer-status.danger { background: rgba(239,68,68,0.15); color: #ef4444; border: 1px solid rgba(239,68,68,0.3); }
        .thermometer-status.warning { background: rgba(234,179,8,0.15); color: #eab308; border: 1px solid rgba(234,179,8,0.3); }
        .thermometer-status.good { background: rgba(34,197,94,0.15); color: #22c55e; border: 1px solid rgba(34,197,94,0.3); }
        .thermometer-status.great { background: rgba(34,197,94,0.25); color: #4ade80; border: 1px solid rgba(34,197,94,0.5); }
        
        /* Trade Gallery */
        .trade-gallery { display: grid; grid-template-columns: repeat(10, 1fr); gap: 4px; }
        .gallery-item { aspect-ratio: 1; border-radius: 4px; position: relative; cursor: pointer; transition: all 0.2s ease; border: 1px solid transparent; }
        .gallery-item:hover { transform: scale(1.3); z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
        .gallery-item.win { background: linear-gradient(135deg, #22c55e, #16a34a); border-color: rgba(34,197,94,0.3); }
        .gallery-item.loss { background: linear-gradient(135deg, #ef4444, #dc2626); border-color: rgba(239,68,68,0.3); }
        .gallery-item.big-win { background: linear-gradient(135deg, #4ade80, #22c55e); box-shadow: 0 0 8px rgba(34,197,94,0.4); border-color: rgba(74,222,128,0.5); }
        .gallery-item.big-loss { background: linear-gradient(135deg, #f87171, #ef4444); box-shadow: 0 0 8px rgba(239,68,68,0.4); border-color: rgba(248,113,113,0.5); }
        .gallery-r { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: rgba(255,255,255,0.95); font-family: monospace; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .gallery-empty { grid-column: span 10; text-align: center; padding: 30px; color: #444; font-size: 12px; }
        .gallery-stats { display: flex; gap: 12px; margin-top: 10px; justify-content: center; }
        .gallery-stat { font-size: 10px; color: #666; }
        .gallery-stat span { font-weight: 600; font-family: monospace; }
        
        /* First Trade of Day */
        .first-trade-wrap { background: rgba(0,0,0,0.2); border-radius: 10px; padding: 12px; }
        .first-trade-stats { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 12px; }
        .first-trade-stat { text-align: center; padding: 10px 8px; border-radius: 8px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); }
        .first-trade-stat.highlight { border-color: rgba(34,197,94,0.4); background: rgba(34,197,94,0.1); }
        .first-trade-stat.highlight.negative { border-color: rgba(239,68,68,0.4); background: rgba(239,68,68,0.1); }
        .first-trade-stat-value { font-family: monospace; font-size: 18px; font-weight: 700; }
        .first-trade-stat-label { font-size: 9px; color: #666; text-transform: uppercase; margin-top: 2px; }
        .first-trade-insight { font-size: 11px; color: #888; padding: 10px; border-radius: 8px; background: rgba(255,255,255,0.02); border-left: 3px solid; margin-top: 8px; }
        .first-trade-insight.positive { border-color: #22c55e; }
        .first-trade-insight.negative { border-color: #ef4444; }
        .first-trade-insight.neutral { border-color: #666; }
        
        /* Collapsible Sections */
        .collapse-header { width: 100%; display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; margin-top: 10px; cursor: pointer; font-size: 12px; font-weight: 600; color: #fff; }
        .collapse-header:active { background: rgba(255,255,255,0.08); }
        .collapse-arrow { transition: transform 0.2s; font-size: 10px; }
        .collapse-arrow.open { transform: rotate(180deg); }
        .collapse-content { display: none; padding-top: 10px; }
        .collapse-content.open { display: block; }
        
        /* View Best Times (Best 2 mode) */
        .view-best-times { background: rgba(59,130,246,0.1); border: 1px solid rgba(59,130,246,0.3); border-radius: 8px; padding: 10px; margin-bottom: 12px; }
        .view-best-header { margin-bottom: 8px; }
        .pred-badge { font-size: 11px; font-weight: 600; padding: 4px 8px; border-radius: 4px; }
        .pred-badge.hot { background: rgba(34,197,94,0.2); color: #22c55e; }
        .pred-badge.warm { background: rgba(234,179,8,0.2); color: #eab308; }
        .pred-badge.cold { background: rgba(239,68,68,0.2); color: #ef4444; }
        .view-best-title { font-size: 11px; font-weight: 600; color: #3b82f6; margin-bottom: 6px; }
        .view-best-list { display: flex; flex-direction: column; gap: 4px; }
        .view-best-item { display: flex; align-items: center; gap: 8px; font-size: 11px; }
        .view-best-rank { color: #3b82f6; font-weight: 700; width: 24px; }
        .view-best-time { color: #fff; flex: 1; }
        .view-best-rate { color: #22c55e; font-weight: 600; }
        .view-best-item.highlighted { background: rgba(34,197,94,0.15); border-radius: 4px; padding: 4px 6px; margin: -4px -6px; }
        .view-best-item.highlighted .view-best-rate { color: #22c55e; font-weight: 700; }
        
        /* Canvas */
        #bgCanvas { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>
    
    <div class="container">
        <div class="header">
            <div style="display:flex;align-items:center;gap:8px;">
                <button class="hamburger-btn" id="hamburgerBtn">‚ò∞</button>
                <div>
                    <div class="title">Trading Journal</div>
                    <div class="subtitle">Trading Year</div>
                </div>
            </div>
            <div class="header-right">
                <button class="clock-btn inactive" id="clockBtn">
                    <span id="clockDisplay">0:00:00 AM</span>
                    <div class="clock-strike" id="clockStrike"></div>
                </button>
                <button class="refresh-btn" id="refreshBtn">‚Üª</button>
            </div>
        </div>
        
        <div class="hamburger-menu" id="hamburgerMenu">
            <button class="menu-item" id="exportBtn"><span class="icon">üì§</span>Export Data</button>
            <button class="menu-item" id="importBtn"><span class="icon">üì•</span>Import Data</button>
        </div>
        <input type="file" accept=".json" id="importFile" style="display:none">
        
        <div class="calendar-wrap" id="calendarWrap">
            <div class="calendar-slider" id="calendarSlider">
                <div class="calendar-page" id="page0">
                    <div class="top3-times" id="top3Times0">
                        <div class="top3-header">üéØ Best Times to Trade</div>
                        <div class="top3-list" id="top3List0">Loading times...</div>
                    </div>
                    <div class="calendar-toggles">
                        <button class="calendar-toggle active" id="calAllTrades0">All Trades</button>
                        <button class="calendar-toggle" id="calBest20">Best 2</button>
                    </div>
                    <div class="week-nav">
                        <button class="week-nav-btn" id="weekPrev0">‚Äπ Prev</button>
                        <span class="week-nav-label" id="weekLabel0">Weeks 1-5</span>
                        <button class="week-nav-btn" id="weekNext0">Next ‚Ä∫</button>
                    </div>
                    <div class="calendar-grid" id="grid0"></div>
                </div>
                <div class="calendar-page" id="page1">
                    <div class="top3-times" id="top3Times1">
                        <div class="top3-header">üéØ Best Times to Trade</div>
                        <div class="top3-list" id="top3List1">Loading times...</div>
                    </div>
                    <div class="calendar-toggles">
                        <button class="calendar-toggle active" id="calAllTrades1">All Trades</button>
                        <button class="calendar-toggle" id="calBest21">Best 2</button>
                    </div>
                    <div class="week-nav">
                        <button class="week-nav-btn" id="weekPrev1">‚Äπ Prev</button>
                        <span class="week-nav-label" id="weekLabel1">Weeks 1-5</span>
                        <button class="week-nav-btn" id="weekNext1">Next ‚Ä∫</button>
                    </div>
                    <div class="calendar-grid" id="grid1"></div>
                </div>
                <div class="calendar-page graph-page" id="page2">
                    <div class="graph-header">
                        <div class="graph-title">üìä All Trades by Time</div>
                        <div class="graph-controls">
                            <button class="graph-ctrl-btn" id="graphZoomOut">‚àí</button>
                            <span class="graph-zoom-level" id="graphZoomLevel">100%</span>
                            <button class="graph-ctrl-btn" id="graphZoomIn">+</button>
                        </div>
                        <div class="graph-trade-count" id="graphTradeCount">0 trades</div>
                    </div>
                    <div class="graph-container" id="graphContainer">
                        <button class="graph-arrow left" id="graphScrollLeft">‚Äπ</button>
                        <div class="graph-scroll-wrap" id="graphScrollWrap">
                            <canvas id="graphCanvas"></canvas>
                        </div>
                        <button class="graph-arrow right" id="graphScrollRight">‚Ä∫</button>
                    </div>
                    
                    <!-- Collapsible Best/Worst Times -->
                    <button class="collapse-header" id="timesCollapseBtn">
                        <span>‚è∞ Best & Worst Times</span>
                        <span class="collapse-arrow" id="timesCollapseArrow">‚ñº</span>
                    </button>
                    <div class="collapse-content" id="timesCollapseContent">
                        <div class="time-extremes" id="timeExtremes">
                            <button class="time-extreme best" id="bestTimeBtn">
                                <div class="time-extreme-label">üî• Best Time <span style="font-size:8px;opacity:0.6">TAP FOR ALL</span></div>
                                <div class="time-extreme-time" id="bestTime">--</div>
                                <div class="time-extreme-stats" id="bestTimeStats">No data yet</div>
                            </button>
                            <button class="time-extreme worst" id="worstTimeBtn">
                                <div class="time-extreme-label">ü•∂ Worst Time <span style="font-size:8px;opacity:0.6">TAP FOR ALL</span></div>
                                <div class="time-extreme-time" id="worstTime">--</div>
                                <div class="time-extreme-stats" id="worstTimeStats">No data yet</div>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Collapsible 2-Trade Strategy -->
                    <button class="collapse-header" id="strategyCollapseBtn">
                        <span>üéØ Your 2-Trade Strategy</span>
                        <span class="collapse-arrow" id="strategyCollapseArrow">‚ñº</span>
                    </button>
                    <div class="collapse-content" id="strategyCollapseContent">
                        <button class="two-trade-btn" id="twoTradeBtn" style="margin-top:0;">
                            <div class="two-trade-header">
                                <span>Best Time Zones</span>
                                <span style="font-size:9px;opacity:0.6">TAP FOR FULL LIST</span>
                            </div>
                            <div class="two-trade-summary" id="twoTradeSummary">Analyzing your best times...</div>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Collapsible Stats Section -->
            <button class="collapse-header" id="statsCollapseBtn">
                <span>üìà Stats</span>
                <span class="collapse-arrow" id="statsCollapseArrow">‚ñº</span>
            </button>
            <div class="collapse-content" id="statsCollapseContent">
                <div class="stats">
                    <div class="stat">
                        <div class="stat-label">Trades</div>
                        <div class="stat-value"><span id="statTrades">0</span></div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Win %</div>
                        <div class="stat-value" id="statWinRate">0%</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">W/L</div>
                        <div class="stat-value"><span class="green" id="statWins">0</span><span class="dim">/</span><span class="red" id="statLosses">0</span></div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Total R</div>
                        <div class="stat-value" id="statR">0.0</div>
                    </div>
                    <button class="stat" id="balanceBtn">
                        <div class="stat-label">Balance</div>
                        <div class="stat-value green" id="statBalance">$1,000</div>
                    </button>
                </div>
            </div>
            
            <!-- Collapsible Progress Section -->
            <button class="collapse-header" id="progressCollapseBtn">
                <span>üèÜ Progress & Goals</span>
                <span class="collapse-arrow" id="progressCollapseArrow">‚ñº</span>
            </button>
            <div class="collapse-content" id="progressCollapseContent">
                <div class="progress-section" style="margin-top:0;">
                    <div class="progress-header">
                        <span class="progress-label">Challenge Progress</span>
                        <span class="progress-value" id="progressDays">0/365 days</span>
                    </div>
                    <div class="progress-bar-wrap">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                </div>
                <div class="goals-row">
                    <button class="goal-box" id="dailyGoalBtn">
                        <div class="goal-label">Daily Goal</div>
                        <div class="goal-progress">
                            <span class="goal-current" id="dailyGoalCurrent">0</span><span class="goal-dim">/</span><span class="goal-target" id="dailyGoalTarget">2R</span>
                        </div>
                    </button>
                    <button class="goal-box" id="weeklyGoalBtn">
                        <div class="goal-label">Weekly Goal</div>
                        <div class="goal-progress">
                            <span class="goal-current" id="weeklyGoalCurrent">0</span><span class="goal-dim">/</span><span class="goal-target" id="weeklyGoalTarget">10R</span>
                        </div>
                    </button>
                    <button class="goal-box" id="weeklyReviewBtn">
                        <div class="goal-label">Review</div>
                        <div class="goal-icon">üìä</div>
                    </button>
                </div>
                <div class="balance-row">
                    <div class="balance-box">
                        <span class="balance-label">Real</span>
                        <span class="balance-value" id="realBalance">$1,000 (+0%)</span>
                    </div>
                    <div class="balance-box">
                        <span class="balance-label">Setups</span>
                        <span class="balance-value" id="setupsBalance">$1,000 (+0%)</span>
                    </div>
                    <div class="balance-box">
                        <span class="balance-label">üéØ Predictions</span>
                        <span class="balance-value" id="predictionAccuracy">0/0 (0%)</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="dots">
            <button class="dot active" id="dot0"></button>
            <button class="dot" id="dot1"></button>
            <button class="dot" id="dot2"></button>
        </div>
    </div>
    
    <!-- Splash Prediction Modal -->
    <div class="modal-overlay hidden" id="splashModal">
        <div class="splash-modal">
            <div class="splash-header" id="splashHeader">üü° CAUTIOUS</div>
            <div class="splash-subtext" id="splashSubtext">Friday was üå§Ô∏è (60%)</div>
            <div class="splash-advice" id="splashAdvice">Only trade top 3 times on Monday</div>
            <div class="splash-times" id="splashTimes"></div>
            <button class="splash-btn" id="splashDismiss">GOT IT</button>
        </div>
    </div>
    
    <!-- Modals -->
    <div class="modal-overlay hidden" id="menuModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="menuTitle">Day 1</div>
                <button class="modal-close" id="menuClose">√ó</button>
            </div>
            <div class="menu-prediction" id="menuPrediction"></div>
            <button class="menu-btn green" id="addTradeBtn"><span class="icon">+</span>Add Trade</button>
            <button class="menu-btn" id="viewTradesBtn"><span class="icon">üìä</span>View Trades</button>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="viewModal">
        <div class="modal">
            <div class="modal-header">
                <button class="modal-back" id="viewBack">‚Üê Back</button>
                <button class="modal-close" id="viewClose">√ó</button>
            </div>
            <div class="modal-title" style="margin-bottom:12px" id="viewTitle">Day 1 Trades</div>
            <div id="tradesList"></div>
            <div class="view-btns">
                <button class="submit-btn" id="viewAddBtn">+ Add Trade</button>
                <button class="submit-btn secondary" id="duplicateBtn">üìã Duplicate Last</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="addModal">
        <div class="modal">
            <div class="modal-header">
                <button class="modal-back" id="addBack">‚Üê Back</button>
                <button class="modal-close" id="addClose">√ó</button>
            </div>
            <div class="modal-title" style="margin-bottom:16px">Add Trade</div>
            <div class="form-group">
                <label class="form-label">Ticker</label>
                <input type="text" class="form-input" id="tickerInput" placeholder="AAPL">
            </div>
            <div class="form-group">
                <label class="form-label">Entry Time</label>
                <select class="form-select" id="entryTimeSelect"></select>
            </div>
            <div class="form-group">
                <label class="form-label">Candles Held <span style="color:#555;font-weight:400">(15 sec each)</span></label>
                <input type="number" class="form-input" id="candlesInput" placeholder="e.g. 4" min="1">
            </div>
            <div class="form-group">
                <label class="form-label">Duration <span id="durationDisplay" style="color:#22c55e;font-weight:600"></span></label>
                <input type="number" class="form-input" id="durationInput" placeholder="Auto-calculated from candles (seconds)" min="1" readonly style="background:#111;color:#666">
            </div>
            <div class="form-group">
                <label class="form-label">R Result</label>
                <div class="r-btns" id="rBtns">
                    <button class="r-btn positive active" data-r="2">+2R</button>
                    <button class="r-btn positive" data-r="1">+1R</button>
                    <button class="r-btn negative" data-r="-1">-1R</button>
                    <button class="r-btn negative" data-r="-2">-2R</button>
                </div>
                <input type="hidden" id="rSelect" value="2">
            </div>
            <div class="form-group">
                <label class="form-label">Type</label>
                <div class="type-btns">
                    <button class="type-btn active" id="typeTaken">Trade Taken</button>
                    <button class="type-btn" id="typeSetup">Setup Only</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Tags</label>
                <div class="tags-wrap" id="tagsWrap">
                    <button class="tag-btn" data-tag="Perfect Setup">‚ú® Perfect Setup</button>
                    <button class="tag-btn" data-tag="FOMO">üò∞ FOMO</button>
                    <button class="tag-btn" data-tag="Revenge">üò§ Revenge</button>
                    <button class="tag-btn" data-tag="Oversize">üìà Oversize</button>
                    <button class="tag-btn" data-tag="Early Entry">‚è∞ Early</button>
                    <button class="tag-btn" data-tag="Late Entry">üê¢ Late</button>
                    <button class="tag-btn" data-tag="Patience">üßò Patience</button>
                    <button class="tag-btn" data-tag="News">üì∞ News</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Notes</label>
                <textarea class="form-input" id="notesInput" placeholder="Trade notes..." rows="3" style="resize:none"></textarea>
            </div>
            <div class="form-group">
                <label class="form-label">Chart Photo</label>
                <input type="file" accept="image/*" capture="environment" id="photoInput" style="display:none">
                <div class="photo-btns">
                    <button class="photo-btn" id="takePhotoBtn">üì∑ Take Photo</button>
                    <button class="photo-btn" id="choosePhotoBtn">üñºÔ∏è Choose Photo</button>
                </div>
                <div id="photoPreview" class="photo-preview"></div>
            </div>
            <button class="submit-btn" id="submitTrade">Add Trade</button>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="editModal">
        <div class="modal">
            <div class="modal-header">
                <button class="modal-back" id="editBack">‚Üê Back</button>
                <button class="modal-close" id="editClose">√ó</button>
            </div>
            <div class="modal-title" style="margin-bottom:16px">Edit Trade</div>
            <div class="form-group">
                <label class="form-label">Ticker</label>
                <input type="text" class="form-input" id="editTickerInput">
            </div>
            <div class="form-group">
                <label class="form-label">Entry Time</label>
                <select class="form-select" id="editEntryTimeSelect"></select>
            </div>
            <div class="form-group">
                <label class="form-label">Candles Held <span style="color:#555;font-weight:400">(15 sec each)</span></label>
                <input type="number" class="form-input" id="editCandlesInput" placeholder="e.g. 4" min="1">
            </div>
            <div class="form-group">
                <label class="form-label">Duration <span id="editDurationDisplay" style="color:#22c55e;font-weight:600"></span></label>
                <input type="number" class="form-input" id="editDurationInput" placeholder="Auto-calculated from candles (seconds)" min="1" readonly style="background:#111;color:#666">
            </div>
            <div class="form-group">
                <label class="form-label">R Result</label>
                <div class="r-btns" id="editRBtns">
                    <button class="r-btn positive" data-r="2">+2R</button>
                    <button class="r-btn positive" data-r="1">+1R</button>
                    <button class="r-btn negative" data-r="-1">-1R</button>
                    <button class="r-btn negative" data-r="-2">-2R</button>
                </div>
                <input type="hidden" id="editRSelect" value="2">
            </div>
            <div class="form-group">
                <label class="form-label">Type</label>
                <div class="type-btns">
                    <button class="type-btn" id="editTypeTaken">Trade Taken</button>
                    <button class="type-btn" id="editTypeSetup">Setup Only</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Tags</label>
                <div class="tags-wrap" id="editTagsWrap">
                    <button class="tag-btn" data-tag="Perfect Setup">‚ú® Perfect Setup</button>
                    <button class="tag-btn" data-tag="FOMO">üò∞ FOMO</button>
                    <button class="tag-btn" data-tag="Revenge">üò§ Revenge</button>
                    <button class="tag-btn" data-tag="Oversize">üìà Oversize</button>
                    <button class="tag-btn" data-tag="Early Entry">‚è∞ Early</button>
                    <button class="tag-btn" data-tag="Late Entry">üê¢ Late</button>
                    <button class="tag-btn" data-tag="Patience">üßò Patience</button>
                    <button class="tag-btn" data-tag="News">üì∞ News</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Notes</label>
                <textarea class="form-input" id="editNotesInput" placeholder="Trade notes..." rows="3" style="resize:none"></textarea>
            </div>
            <div class="form-group">
                <label class="form-label">Chart Photo</label>
                <input type="file" accept="image/*" capture="environment" id="editPhotoInput" style="display:none">
                <div class="photo-btns">
                    <button class="photo-btn" id="editTakePhotoBtn">üì∑ Take Photo</button>
                    <button class="photo-btn" id="editChoosePhotoBtn">üñºÔ∏è Choose Photo</button>
                </div>
                <div id="editPhotoPreview" class="photo-preview"></div>
            </div>
            <button class="submit-btn" id="saveEdit">Save Changes</button>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="weekModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="weekTitle">Week 1</div>
                <button class="modal-close" id="weekClose">√ó</button>
            </div>
            <div class="week-section">
                <div class="week-section-title">üéØ Best Times This Week</div>
                <div class="week-best-times-list" id="weekBestTimes">Loading...</div>
            </div>
            <div class="week-section">
                <div class="week-section-title">Your Trades</div>
                <div class="week-grid">
                    <div class="week-stat full" id="weekMyR"></div>
                    <div class="week-stat"><div class="week-stat-value" id="weekMyTrades">0</div><div class="week-stat-label">TRADES</div></div>
                    <div class="week-stat"><div class="week-stat-value" id="weekMyWinRate">0%</div><div class="week-stat-label">WIN RATE</div></div>
                    <div class="week-stat"><div class="week-stat-value green" id="weekMyWins">0</div><div class="week-stat-label">WINS</div></div>
                    <div class="week-stat"><div class="week-stat-value red" id="weekMyLosses">0</div><div class="week-stat-label">LOSSES</div></div>
                </div>
            </div>
            <div class="week-section">
                <div class="week-section-title">All Setups</div>
                <div class="week-grid">
                    <div class="week-stat full" id="weekAllR"></div>
                    <div class="week-stat"><div class="week-stat-value" id="weekAllTrades">0</div><div class="week-stat-label">SETUPS</div></div>
                    <div class="week-stat"><div class="week-stat-value" id="weekAllWinRate">0%</div><div class="week-stat-label">WIN RATE</div></div>
                    <div class="week-stat"><div class="week-stat-value green" id="weekAllWins">0</div><div class="week-stat-label">WINS</div></div>
                    <div class="week-stat"><div class="week-stat-value red" id="weekAllLosses">0</div><div class="week-stat-label">LOSSES</div></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="clearModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Clear Data</div>
                <button class="modal-close" id="clearClose">√ó</button>
            </div>
            <p class="modal-text">Which page to clear?</p>
            <button class="clear-btn" id="clearPage1">Page 1 (Days 1-25)</button>
            <button class="clear-btn" id="clearPage2">Page 2 (Days 26-50)</button>
            <button class="cancel-btn" id="clearCancel">Cancel</button>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="balanceModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Set Balance</div>
                <button class="modal-close" id="balanceClose">√ó</button>
            </div>
            <p class="modal-text">Current: <span id="currentBalance">$1,000</span></p>
            <div class="form-group">
                <input type="number" class="form-input" id="balanceInput" placeholder="Enter amount">
            </div>
            <div class="balance-presets">
                <button class="balance-preset" data-amount="100">$100</button>
                <button class="balance-preset" data-amount="500">$500</button>
                <button class="balance-preset" data-amount="1000">$1,000</button>
                <button class="balance-preset" data-amount="5000">$5,000</button>
                <button class="balance-preset" data-amount="10000">$10,000</button>
                <button class="balance-preset" data-amount="50000">$50,000</button>
            </div>
            <button class="submit-btn" id="saveBalance">Set Balance</button>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="reviewModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Weekly Review</div>
                <button class="modal-close" id="reviewClose">√ó</button>
            </div>
            <div class="calendar-toggles" style="margin-bottom:12px;">
                <button class="calendar-toggle active" id="reviewMyTrades">My Trades</button>
                <button class="calendar-toggle" id="reviewAllTrades">All Trades</button>
            </div>
            <div class="review-content" id="reviewContent"></div>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="goalModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="goalModalTitle">Set Daily Goal</div>
                <button class="modal-close" id="goalClose">√ó</button>
            </div>
            <div class="form-group">
                <label class="form-label">Target R</label>
                <input type="number" class="form-input" id="goalInput" placeholder="Enter target R" step="0.5">
            </div>
            <div class="balance-presets">
                <button class="goal-preset" data-amount="1">1R</button>
                <button class="goal-preset" data-amount="2">2R</button>
                <button class="goal-preset" data-amount="3">3R</button>
                <button class="goal-preset" data-amount="4">4R</button>
                <button class="goal-preset" data-amount="5">5R</button>
                <button class="goal-preset" data-amount="10">10R</button>
            </div>
            <button class="submit-btn" id="saveGoal">Set Goal</button>
        </div>
    </div>
    
    <div class="modal-overlay hidden" id="timeRankModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="timeRankTitle">Time Ranking</div>
                <button class="modal-close" id="timeRankClose">√ó</button>
            </div>
            <div class="time-rank-list" id="timeRankList"></div>
        </div>
    </div>

    <script>
        // IndexedDB for large storage (hundreds of MB)
        let db;
        const DB_NAME = 'TradingJournalDB';
        const DB_VERSION = 1;
        
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => { db = request.result; resolve(db); };
                request.onupgradeneeded = (e) => {
                    const database = e.target.result;
                    if (!database.objectStoreNames.contains('data')) {
                        database.createObjectStore('data', { keyPath: 'id' });
                    }
                };
            });
        }
        
        function saveToDB(key, value) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction('data', 'readwrite');
                const store = tx.objectStore('data');
                store.put({ id: key, value: value });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }
        
        function loadFromDB(key) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction('data', 'readonly');
                const store = tx.objectStore('data');
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result ? request.result.value : null);
                request.onerror = () => reject(request.error);
            });
        }
        
        // Data
        let days = Array.from({length: 365}, (_, i) => ({ id: i, trades: [] }));
        let weekOffset = 0; // Which set of 5 weeks to show (0 = weeks 1-5, 1 = weeks 6-10, etc.)
        let startingBalance = 1000;
        let currentPage = 0;
        let selectedDay = null;
        let selectedWeek = null;
        let editingTrade = null;
        let newTradeTaken = true;
        let editTradeTaken = true;
        let newTradePhoto = null;
        let editTradePhoto = null;
        let newTradeTags = [];
        let editTradeTags = [];
        let currentGoalType = 'daily'; // 'daily' or 'weekly'
        let todayIndex = 0; // Which day is "today" in the challenge
        let graphShowAll = true; // Always show all trades
        let graphZoom = 100; // Zoom percentage (50-200)
        let graphCompareMode = false; // true = show both overlaid
        let calendarShowAll = false; // false = my trades, true = all trades
        let calendarMode = 'all'; // 'all' = all trades, 'best2' = best 2 trades from best window
        let dailyGoal = 2; // Target R per day
        let weeklyGoal = 10; // Target R per week
        
        // Audio
        let audioCtx = null;
        let beepOn = false;
        let lastSecond = -1;
        
        function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        function playBeep(freq, dur) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.frequency.value = freq; osc.type = 'sine';
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.start(); osc.stop(audioCtx.currentTime + dur);
        }
        
        // Clock
        function updateClock() {
            const now = new Date();
            let h = now.getHours(), m = now.getMinutes(), s = now.getSeconds();
            const ap = h >= 12 ? 'PM' : 'AM';
            h = h % 12 || 12;
            document.getElementById('clockDisplay').textContent = `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')} ${ap}`;
            
            if (beepOn && s !== lastSecond) {
                lastSecond = s;
                if ([10,11,12,13,25,26,27,28,40,41,42,43,55,56,57,58].includes(s)) playBeep(440, 0.15);
                else if ([14,29,44,59].includes(s)) { playBeep(440, 0.15); setTimeout(() => playBeep(600, 0.2), 650); }
                else if ([0,15,30,45].includes(s)) playBeep(880, 0.3);
            }
        }
        setInterval(updateClock, 100);
        updateClock();
        
        document.getElementById('clockBtn').addEventListener('click', () => {
            initAudio();
            beepOn = !beepOn;
            const btn = document.getElementById('clockBtn');
            const strike = document.getElementById('clockStrike');
            if (beepOn) { btn.classList.remove('inactive'); btn.classList.add('active'); strike.style.display = 'none'; }
            else { btn.classList.remove('active'); btn.classList.add('inactive'); strike.style.display = 'block'; }
        });
        
        // Canvas animation
        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        for (let i = 0; i < 60; i++) particles.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5, s: Math.random() * 2.5 + 1, o: Math.random() * 0.4 + 0.1 });
        
        function drawParticles() {
            ctx.fillStyle = 'rgba(8,8,12,0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy;
                if (p.x < 0) p.x = canvas.width; if (p.x > canvas.width) p.x = 0;
                if (p.y < 0) p.y = canvas.height; if (p.y > canvas.height) p.y = 0;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(34,197,94,${p.o})`; ctx.fill();
                particles.slice(i + 1).forEach(p2 => {
                    const d = Math.hypot(p.x - p2.x, p.y - p2.y);
                    if (d < 120) { ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p2.x, p2.y); ctx.strokeStyle = `rgba(34,197,94,${0.15 * (1 - d / 120)})`; ctx.lineWidth = 0.5; ctx.stroke(); }
                });
            });
            requestAnimationFrame(drawParticles);
        }
        drawParticles();
        
        // Time options
        const times = [];
        for (let h = 4; h <= 8; h++) for (let m = 0; m < 60; m += 15) times.push(`${h}:${m.toString().padStart(2,'0')} AM`);
        for (let h = 9; h <= 11; h++) for (let m = 0; m < 60; m += 5) times.push(`${h}:${m.toString().padStart(2,'0')} AM`);
        times.push('12:00 PM');
        for (let m = 5; m < 60; m += 5) times.push(`12:${m.toString().padStart(2,'0')} PM`);
        for (let h = 1; h <= 4; h++) for (let m = 0; m < 60; m += 15) times.push(`${h}:${m.toString().padStart(2,'0')} PM`);
        
        // Populate all time selects
        ['entryTimeSelect', 'editEntryTimeSelect'].forEach(id => {
            const sel = document.getElementById(id);
            times.forEach(t => { const opt = document.createElement('option'); opt.value = t; opt.textContent = t; sel.appendChild(opt); });
            sel.value = '9:30 AM';
        });
        
        // Parse time to minutes since midnight
        function parseTimeToMinutes(timeStr) {
            const match = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
            if (!match) return 0;
            let h = parseInt(match[1]);
            const m = parseInt(match[2]);
            const ampm = match[3].toUpperCase();
            if (ampm === 'PM' && h !== 12) h += 12;
            if (ampm === 'AM' && h === 12) h = 0;
            return h * 60 + m;
        }
        
        // Calculate duration from candles (each candle = 15 seconds)
        function updateDurationFromCandles(candlesId, durationId, displayId) {
            const candles = parseInt(document.getElementById(candlesId).value) || 0;
            if (candles > 0) {
                const durationSecs = candles * 15;
                document.getElementById(durationId).value = durationSecs;
                
                // Format display
                if (durationSecs >= 60) {
                    const mins = Math.floor(durationSecs / 60);
                    const secs = durationSecs % 60;
                    document.getElementById(displayId).textContent = secs > 0 ? `(${mins}m ${secs}s)` : `(${mins}m)`;
                } else {
                    document.getElementById(displayId).textContent = `(${durationSecs}s)`;
                }
            } else {
                document.getElementById(durationId).value = '';
                document.getElementById(displayId).textContent = '';
            }
        }
        
        // Add listeners for candle input
        document.getElementById('candlesInput').addEventListener('input', () => updateDurationFromCandles('candlesInput', 'durationInput', 'durationDisplay'));
        document.getElementById('editCandlesInput').addEventListener('input', () => updateDurationFromCandles('editCandlesInput', 'editDurationInput', 'editDurationDisplay'));
        
        // Save data
        function saveData() { 
            saveToDB('days', days);
            saveToDB('balance', startingBalance);
        }
        
        // Calculate stats
        // Check if a day has P:SITOUT prediction (based on previous day)
        function isDaySitout(dayIndex) {
            if (dayIndex <= 0) return false;
            const pred = predictNextDay(dayIndex - 1);
            return pred && pred.prediction === 'cold';
        }
        
        function calcStats() {
            let myCount = 0, myWins = 0, myLosses = 0, myR = 0;
            let allCount = 0, allWins = 0, allLosses = 0, allR = 0;
            days.forEach((d, dayIndex) => {
                // Skip P:SITOUT days - their trades don't count toward stats
                if (isDaySitout(dayIndex)) return;
                
                d.trades.forEach(t => {
                    allCount++; allR += t.r; 
                    if (t.r > 0) allWins++; else if (t.r < 0) allLosses++;
                    if (t.taken) { 
                        myCount++; myR += t.r; 
                        if (t.r > 0) myWins++; else if (t.r < 0) myLosses++; 
                    }
                });
            });
            return { myCount, myWins, myLosses, myR, allCount, allWins, allLosses, allR };
        }
        
        function calcWeek(wi) {
            const startIdx = wi * 5;
            const wd = days.slice(startIdx, startIdx + 5);
            let my = 0, myW = 0, myL = 0, myR = 0, all = 0, allW = 0, allL = 0, allR = 0;
            wd.forEach((d, i) => {
                const dayIndex = startIdx + i;
                // Skip P:SITOUT days
                if (isDaySitout(dayIndex)) return;
                
                d.trades.forEach(t => {
                    all++; allR += t.r; if (t.r > 0) allW++; else if (t.r < 0) allL++;
                    if (t.taken) { my++; myR += t.r; if (t.r > 0) myW++; else if (t.r < 0) myL++; }
                });
            });
            return { my, myW, myL, myR, all, allW, allL, allR };
        }
        
        function dayR(d) { return d.trades.filter(t => t.taken).reduce((s, t) => s + t.r, 0); }
        
        let graphSlots = []; // Store slots for click detection
        
        function renderGraph(animate = true) {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('graphScrollWrap');
            
            // First, count the slots to determine canvas width
            const timeSlots = {};
            let totalTradeCount = 0;
            days.forEach((d, dayIndex) => {
                d.trades.forEach(t => {
                    if (graphShowAll || t.taken) {
                        totalTradeCount++;
                        const timeKey = t.time;
                        if (!timeSlots[timeKey]) {
                            timeSlots[timeKey] = { positiveR: 0, negativeR: 0, positiveCount: 0, negativeCount: 0, time: t.time, trades: [] };
                        }
                        if (t.r >= 0) {
                            timeSlots[timeKey].positiveR += t.r;
                            timeSlots[timeKey].positiveCount++;
                        } else {
                            timeSlots[timeKey].negativeR += t.r;
                            timeSlots[timeKey].negativeCount++;
                        }
                        timeSlots[timeKey].trades.push({ ...t, dayIndex });
                    }
                });
            });
            
            const slots = Object.values(timeSlots);
            slots.sort((a, b) => {
                const parseTime = (t) => {
                    const parts = t.match(/(\d+):(\d+)\s*(AM|PM)/i);
                    if (!parts) return 0;
                    let h = parseInt(parts[1]);
                    const m = parseInt(parts[2]);
                    const ampm = parts[3].toUpperCase();
                    if (ampm === 'PM' && h !== 12) h += 12;
                    if (ampm === 'AM' && h === 12) h = 0;
                    return h * 60 + m;
                };
                return parseTime(a.time) - parseTime(b.time);
            });
            
            // Calculate canvas width based on number of slots and zoom
            const barWidth = Math.round(30 * (graphZoom / 100));
            const gap = Math.round(20 * (graphZoom / 100));
            const minCanvasWidth = container.clientWidth;
            const neededWidth = slots.length > 0 ? (slots.length * (barWidth + gap)) + 80 : minCanvasWidth;
            const canvasWidth = Math.max(minCanvasWidth, neededWidth);
            
            // Set canvas size
            const height = 350;
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = height + 'px';
            canvas.width = canvasWidth * 2;
            canvas.height = height * 2;
            ctx.scale(2, 2);
            
            const padding = { top: 25, right: 20, bottom: 50, left: 40 };
            const graphWidth = canvasWidth - padding.left - padding.right;
            const graphHeight = height - padding.top - padding.bottom;
            
            // Update trade count display
            const tradeCountEl = document.getElementById('graphTradeCount');
            if (tradeCountEl) {
                tradeCountEl.textContent = totalTradeCount + ' trades';
            }
            
            // Update zoom level display
            const zoomEl = document.getElementById('graphZoomLevel');
            if (zoomEl) {
                zoomEl.textContent = graphZoom + '%';
            }
            
            // Find max R for scaling
            const maxPositive = Math.max(...slots.map(s => s.positiveR), 1);
            const maxNegative = Math.max(...slots.map(s => Math.abs(s.negativeR)), 1);
            const maxR = Math.max(4, maxPositive, maxNegative);
            
            const zeroY = padding.top + graphHeight / 2;
            
            // Bar positioning - evenly spaced starting from left
            const startX = padding.left;
            
            // Store bar positions for click detection
            graphSlots = slots.map((slot, i) => ({
                ...slot,
                x: startX + i * (barWidth + gap),
                barWidth: barWidth,
                zeroY: zeroY,
                maxR: maxR,
                graphHeight: graphHeight
            }));
            
            function drawFrame(progress) {
                // Clear
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(0, 0, canvasWidth, height);
                
                // Draw zero line
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding.left, zeroY);
                ctx.lineTo(canvasWidth - padding.right, zeroY);
                ctx.stroke();
                
                // Draw R labels
                ctx.fillStyle = '#555';
                ctx.font = '11px monospace';
                ctx.textAlign = 'right';
                ctx.fillText('+' + maxR + 'R', padding.left - 5, padding.top + 10);
                ctx.fillText('0', padding.left - 5, zeroY + 4);
                ctx.fillText('-' + maxR + 'R', padding.left - 5, padding.top + graphHeight - 2);
                
                if (slots.length === 0) {
                    ctx.fillStyle = '#555';
                    ctx.font = '12px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText('No trades yet', canvasWidth / 2, height / 2);
                    return;
                }
                
                // Draw bars with animation
                slots.forEach((slot, i) => {
                    const x = graphSlots[i].x;
                    const total = slot.positiveCount + slot.negativeCount;
                    const winRate = total > 0 ? Math.round((slot.positiveCount / total) * 100) : 0;
                    // Format time label - show hour and AM/PM clearly
                    const timeParts = slot.time.match(/(\d+):(\d+)\s*(AM|PM)/i);
                    const timeLabel = timeParts ? timeParts[1] + ':' + timeParts[2] : slot.time;
                    const ampm = timeParts ? timeParts[3].toUpperCase() : '';
                    
                    // Calculate bar heights
                    const posBarHeight = slot.positiveR > 0 ? (slot.positiveR / maxR) * (graphHeight / 2) * progress : 0;
                    const negBarHeight = slot.negativeR < 0 ? (Math.abs(slot.negativeR) / maxR) * (graphHeight / 2) * progress : 0;
                    
                    // Green bar (positive) going UP
                    if (slot.positiveR > 0) {
                        const y = zeroY - posBarHeight;
                        
                        ctx.fillStyle = 'rgba(34,197,94,0.85)';
                        ctx.fillRect(x, y, barWidth, posBarHeight);
                        ctx.strokeStyle = '#22c55e';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, barWidth, posBarHeight);
                        
                        // R value above bar
                        if (progress > 0.7) {
                            const textAlpha = (progress - 0.7) / 0.3;
                            ctx.fillStyle = `rgba(34,197,94,${textAlpha})`;
                            ctx.font = 'bold 10px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText('+' + slot.positiveR + 'R', x + barWidth / 2, y - 5);
                        }
                    }
                    
                    // Red bar (negative) going DOWN
                    if (slot.negativeR < 0) {
                        const y = zeroY;
                        
                        ctx.fillStyle = 'rgba(239,68,68,0.85)';
                        ctx.fillRect(x, y, barWidth, negBarHeight);
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, barWidth, negBarHeight);
                        
                        // R value below bar
                        if (progress > 0.7) {
                            const textAlpha = (progress - 0.7) / 0.3;
                            ctx.fillStyle = `rgba(239,68,68,${textAlpha})`;
                            ctx.font = 'bold 10px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText(slot.negativeR + 'R', x + barWidth / 2, y + negBarHeight + 12);
                        }
                    }
                    
                    // Always show time label at bottom - TWO LINES: time and AM/PM
                    if (progress > 0.5) {
                        const textAlpha = (progress - 0.5) / 0.5;
                        ctx.fillStyle = `rgba(200,200,200,${textAlpha})`;
                        ctx.font = 'bold 11px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(timeLabel, x + barWidth / 2, height - 22);
                        ctx.font = '10px monospace';
                        ctx.fillStyle = `rgba(150,150,150,${textAlpha})`;
                        ctx.fillText(ampm, x + barWidth / 2, height - 8);
                    }
                });
            }
            
            if (animate && slots.length > 0) {
                let startTime = null;
                const duration = 500;
                
                function animateFrame(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easedProgress = 1 - Math.pow(1 - progress, 3);
                    drawFrame(easedProgress);
                    if (progress < 1) {
                        requestAnimationFrame(animateFrame);
                    }
                }
                
                requestAnimationFrame(animateFrame);
            } else {
                drawFrame(1);
            }
            
            // Update best/worst time slots
            renderTimeExtremes();
            renderZoneAnalysis();
        }
        
        function openGraphTradesModal(slot) {
            const list = document.getElementById('tradesList');
            list.innerHTML = '';
            document.getElementById('viewTitle').textContent = 'Trades at ' + slot.time;
            
            if (slot.trades.length === 0) {
                list.innerHTML = '<div class="empty-state"><div class="empty-icon">üì≠</div>No trades</div>';
            } else {
                slot.trades.forEach(t => {
                    const div = document.createElement('div');
                    div.className = 'trade-item' + (t.taken ? '' : ' setup');
                    div.innerHTML = '<div class="trade-info"><div class="trade-ticker">' + t.ticker + ' <span style="font-size:9px;color:#555">D' + (t.dayIndex + 1) + '</span>' + (t.taken ? '' : '<span style="font-size:9px;color:#555;margin-left:4px">(setup)</span>') + '</div><div class="trade-time">' + t.time + '</div></div><span class="trade-r ' + (t.r >= 0 ? 'green' : 'red') + '">' + (t.r > 0 ? '+' : '') + t.r + 'R</span>';
                    list.appendChild(div);
                });
            }
            
            // Hide back button and add trade button for graph view
            document.getElementById('viewBack').style.display = 'none';
            document.getElementById('viewAddBtn').style.display = 'none';
            hideAllModals();
            document.getElementById('viewModal').classList.remove('hidden');
        }
        
        // ============ ANALYTICS FUNCTIONS ============
        
        // Render P&L Thermometer
        function renderThermometer() {
            // Get today's R (from the most recent day with trades)
            let todayR = 0;
            for (let i = days.length - 1; i >= 0; i--) {
                const hasTrades = calendarShowAll ? days[i].trades.length > 0 : days[i].trades.some(t => t.taken);
                if (hasTrades) {
                    const trades = calendarShowAll ? days[i].trades : days[i].trades.filter(t => t.taken);
                    todayR = trades.reduce((sum, t) => sum + t.r, 0);
                    break;
                }
            }
            
            const target = dailyGoal;
            const dangerZone = -2;
            const maxDisplay = Math.max(target * 1.5, 4);
            const minDisplay = Math.min(dangerZone * 1.5, -4);
            const range = maxDisplay - minDisplay;
            
            // Calculate position (0 = bottom, 100 = top)
            const position = Math.max(0, Math.min(100, ((todayR - minDisplay) / range) * 100));
            
            // Update thermometer visuals
            document.getElementById('thermoFill').style.height = (100 - position) + '%';
            document.getElementById('thermoMarker').style.bottom = position + '%';
            
            // Update current R display
            const currentEl = document.getElementById('thermoCurrent');
            currentEl.textContent = (todayR > 0 ? '+' : '') + todayR.toFixed(1) + 'R';
            currentEl.className = 'thermometer-current ' + (todayR >= 0 ? 'green' : 'red');
            
            // Update target display
            document.getElementById('thermoTarget').textContent = target + 'R';
            
            // Update status
            const statusEl = document.getElementById('thermoStatus');
            if (todayR >= target * 1.5) {
                statusEl.textContent = 'üöÄ Crushing It!';
                statusEl.className = 'thermometer-status great';
            } else if (todayR >= target) {
                statusEl.textContent = 'üéØ Goal Hit!';
                statusEl.className = 'thermometer-status good';
            } else if (todayR > 0) {
                statusEl.textContent = 'üìà In Profit';
                statusEl.className = 'thermometer-status good';
            } else if (todayR === 0) {
                statusEl.textContent = '‚è≥ Starting Fresh';
                statusEl.className = 'thermometer-status warning';
            } else if (todayR > dangerZone) {
                statusEl.textContent = '‚ö†Ô∏è Down Today';
                statusEl.className = 'thermometer-status warning';
            } else {
                statusEl.textContent = 'üö® Danger Zone';
                statusEl.className = 'thermometer-status danger';
            }
        }
        
        // Render Trade Gallery
        function renderTradeGallery() {
            const allTrades = [];
            days.forEach((d, di) => {
                d.trades.forEach(t => {
                    if (calendarShowAll || t.taken) {
                        allTrades.push({ ...t, dayIndex: di });
                    }
                });
            });
            
            // Sort by day index, then by entry time
            allTrades.sort((a, b) => {
                // First sort by day
                if (a.dayIndex !== b.dayIndex) {
                    return a.dayIndex - b.dayIndex;
                }
                // Then sort by time within the same day
                const parseTime = (t) => {
                    const timeStr = t.entryTime || t.time || '12:00 PM';
                    const parts = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                    if (!parts) return 0;
                    let h = parseInt(parts[1]);
                    const m = parseInt(parts[2]);
                    const ampm = parts[3].toUpperCase();
                    if (ampm === 'PM' && h !== 12) h += 12;
                    if (ampm === 'AM' && h === 12) h = 0;
                    return h * 60 + m;
                };
                return parseTime(a) - parseTime(b);
            });
            
            // Get last 50 trades
            const recentTrades = allTrades.slice(-50);
            
            const container = document.getElementById('tradeGallery');
            const statsContainer = document.getElementById('galleryStats');
            
            if (recentTrades.length === 0) {
                container.innerHTML = '<div class="gallery-empty">No trades yet ‚Äî start trading to see your history!</div>';
                statsContainer.innerHTML = '';
                return;
            }
            
            // Calculate stats for the gallery
            const wins = recentTrades.filter(t => t.r > 0).length;
            const losses = recentTrades.filter(t => t.r < 0).length;
            const totalR = recentTrades.reduce((sum, t) => sum + t.r, 0);
            const winRate = recentTrades.length > 0 ? Math.round((wins / recentTrades.length) * 100) : 0;
            
            container.innerHTML = recentTrades.map(t => {
                let cls = t.r > 0 ? 'win' : 'loss';
                if (t.r >= 2) cls = 'big-win';
                else if (t.r <= -2) cls = 'big-loss';
                return `<div class="gallery-item ${cls}" title="${t.ticker} @ ${t.time} | Day ${t.dayIndex + 1} | ${t.r > 0 ? '+' : ''}${t.r}R">
                    <div class="gallery-r">${t.r > 0 ? '+' : ''}${t.r}</div>
                </div>`;
            }).join('');
            
            statsContainer.innerHTML = `
                <div class="gallery-stat">Showing <span class="green">${recentTrades.length}</span> trades</div>
                <div class="gallery-stat">Win Rate <span class="${winRate >= 50 ? 'green' : 'red'}">${winRate}%</span></div>
                <div class="gallery-stat">Total <span class="${totalR >= 0 ? 'green' : 'red'}">${totalR > 0 ? '+' : ''}${totalR.toFixed(1)}R</span></div>
            `;
        }
        
        // Render Day of Week Performance
        function renderDayOfWeek() {
            const dowData = {
                'Mon': { r: 0, trades: 0, wins: 0 },
                'Tue': { r: 0, trades: 0, wins: 0 },
                'Wed': { r: 0, trades: 0, wins: 0 },
                'Thu': { r: 0, trades: 0, wins: 0 },
                'Fri': { r: 0, trades: 0, wins: 0 }
            };
            
            const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
            
            // Aggregate data by day of week based on position in calendar
            // Each row has 5 days: Mon(0), Tue(1), Wed(2), Thu(3), Fri(4)
            days.forEach((d, index) => {
                const dayOfWeek = dayNames[index % 5]; // Position in week (0-4)
                d.trades.forEach(t => {
                    if (calendarShowAll || t.taken) {
                        dowData[dayOfWeek].r += t.r;
                        dowData[dayOfWeek].trades++;
                        if (t.r > 0) dowData[dayOfWeek].wins++;
                    }
                });
            });
            
            const container = document.getElementById('dowHeatmap');
            const dayOrder = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
            
            // Find max R for relative coloring
            const maxAbsR = Math.max(...Object.values(dowData).map(d => Math.abs(d.r)), 1);
            
            // Find best and worst days
            let bestDay = null, worstDay = null;
            let bestR = -Infinity, worstR = Infinity;
            dayOrder.forEach(day => {
                if (dowData[day].trades > 0) {
                    if (dowData[day].r > bestR) { bestR = dowData[day].r; bestDay = day; }
                    if (dowData[day].r < worstR) { worstR = dowData[day].r; worstDay = day; }
                }
            });
            
            container.innerHTML = dayOrder.map(day => {
                const data = dowData[day];
                const winRate = data.trades > 0 ? Math.round((data.wins / data.trades) * 100) : 0;
                
                // Determine heat class
                let heatClass = '';
                if (data.trades > 0) {
                    const intensity = data.r / maxAbsR;
                    if (intensity > 0.5) heatClass = 'hot';
                    else if (intensity > 0) heatClass = 'warm';
                    else if (intensity > -0.5) heatClass = 'cold';
                    else heatClass = 'freezing';
                }
                
                // Badge for best/worst
                let badge = '';
                if (day === bestDay && bestR > 0) badge = '<div class="dow-badge">üî•</div>';
                else if (day === worstDay && worstR < 0) badge = '<div class="dow-badge">ü•∂</div>';
                
                return `<div class="dow-item ${heatClass}">
                    ${badge}
                    <div class="dow-day">${day.toUpperCase()}</div>
                    <div class="dow-r ${data.r >= 0 ? 'green' : 'red'}">${data.r > 0 ? '+' : ''}${data.r.toFixed(1)}R</div>
                    <div class="dow-trades">${data.trades} trade${data.trades !== 1 ? 's' : ''}</div>
                    <div class="dow-winrate ${winRate >= 50 ? 'green' : data.trades > 0 ? 'red' : ''}">${data.trades > 0 ? winRate + '%' : '-'}</div>
                </div>`;
            }).join('');
        }
        
        // Render Best/Worst Time Slots
        function renderTimeExtremes() {
            const timeSlots = {};
            
            days.forEach(d => {
                d.trades.forEach(t => {
                    if (graphShowAll || t.taken) {
                        if (!timeSlots[t.time]) {
                            timeSlots[t.time] = { greenR: 0, redR: 0, trades: 0, wins: 0, losses: 0, time: t.time };
                        }
                        timeSlots[t.time].trades++;
                        if (t.r > 0) {
                            timeSlots[t.time].greenR += t.r;
                            timeSlots[t.time].wins++;
                        } else if (t.r < 0) {
                            timeSlots[t.time].redR += Math.abs(t.r);
                            timeSlots[t.time].losses++;
                        }
                    }
                });
            });
            
            // Group into 15-minute ranges and calculate ratios
            const timeRanges = {};
            Object.values(timeSlots).forEach(slot => {
                // Parse time to get the 15-min bucket
                const parts = slot.time.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!parts) return;
                let h = parseInt(parts[1]);
                const m = parseInt(parts[2]);
                const ampm = parts[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                const totalMinutes = h * 60 + m;
                const bucketStart = Math.floor(totalMinutes / 15) * 15;
                
                // Format bucket as time range
                const formatTime = (mins) => {
                    let hr = Math.floor(mins / 60);
                    const mn = mins % 60;
                    const ap = hr >= 12 ? 'PM' : 'AM';
                    if (hr > 12) hr -= 12;
                    if (hr === 0) hr = 12;
                    return hr + ':' + mn.toString().padStart(2, '0') + ' ' + ap;
                };
                const rangeKey = formatTime(bucketStart);
                
                if (!timeRanges[rangeKey]) {
                    timeRanges[rangeKey] = { greenR: 0, redR: 0, trades: 0, wins: 0, losses: 0, time: rangeKey, bucketStart };
                }
                timeRanges[rangeKey].greenR += slot.greenR;
                timeRanges[rangeKey].redR += slot.redR;
                timeRanges[rangeKey].trades += slot.trades;
                timeRanges[rangeKey].wins += slot.wins;
                timeRanges[rangeKey].losses += slot.losses;
            });
            
            // Calculate ratio for each range (greenR / redR)
            const ranges = Object.values(timeRanges).filter(r => r.trades >= 1);
            ranges.forEach(r => {
                // Net R (profit minus loss)
                r.netR = r.greenR - r.redR;
                r.winRate = r.trades > 0 ? Math.round((r.wins / r.trades) * 100) : 0;
            });
            
            if (ranges.length === 0) {
                document.getElementById('bestTime').textContent = '--';
                document.getElementById('bestTimeStats').textContent = 'No data yet';
                document.getElementById('worstTime').textContent = '--';
                document.getElementById('worstTimeStats').textContent = 'No data yet';
                window.sortedTimeSlots = [];
                return;
            }
            
            // Sort by net R (best profit first)
            ranges.sort((a, b) => b.netR - a.netR);
            
            // For best/worst, prefer ranges with 3+ trades
            const qualifiedRanges = ranges.filter(r => r.trades >= 3);
            const bestSource = qualifiedRanges.length >= 1 ? qualifiedRanges : ranges;
            const worstSource = qualifiedRanges.length >= 2 ? qualifiedRanges : ranges;
            
            const best = bestSource[0];
            const worst = worstSource[worstSource.length - 1];
            
            // Best time - show clear stats
            document.getElementById('bestTime').innerHTML = `<span class="green">${best.time}</span>`;
            document.getElementById('bestTimeStats').innerHTML = `<span class="green" style="font-weight:700">${best.winRate}% win</span> ¬∑ <span class="green">+${best.greenR.toFixed(0)}R</span> / <span class="red">-${best.redR.toFixed(0)}R</span> ¬∑ ${best.trades} trades`;
            
            // Worst time
            document.getElementById('worstTime').innerHTML = `<span class="red">${worst.time}</span>`;
            document.getElementById('worstTimeStats').innerHTML = `<span class="red" style="font-weight:700">${worst.winRate}% win</span> ¬∑ <span class="green">+${worst.greenR.toFixed(0)}R</span> / <span class="red">-${worst.redR.toFixed(0)}R</span> ¬∑ ${worst.trades} trades`;
            
            // Store sorted ranges for modal
            window.sortedTimeSlots = ranges;
        }
        
        // Show Time Ranking Modal
        function showTimeRankModal(type) {
            const slots = window.sortedTimeSlots || [];
            if (slots.length === 0) return;
            
            const title = type === 'best' ? 'üî• Best Times (by Net R)' : 'ü•∂ Worst Times (by Net R)';
            const sortedSlots = type === 'best' ? [...slots] : [...slots].reverse();
            
            document.getElementById('timeRankTitle').textContent = title;
            
            const listHtml = sortedSlots.map((slot, i) => {
                const netR = slot.netR;
                const isGood = netR >= 0;
                return `<div class="time-rank-item ${isGood ? 'positive' : 'negative'}">
                    <div class="time-rank-pos">#${i + 1}</div>
                    <div class="time-rank-time">${slot.time}</div>
                    <div>
                        <div class="time-rank-r ${isGood ? 'green' : 'red'}" style="font-size:16px">${netR > 0 ? '+' : ''}${netR.toFixed(1)}R net</div>
                        <div class="time-rank-details">${slot.winRate}% win ¬∑ <span class="green">+${slot.greenR.toFixed(0)}R</span> / <span class="red">-${slot.redR.toFixed(0)}R</span> ¬∑ ${slot.trades} trades</div>
                    </div>
                </div>`;
            }).join('');
            
            document.getElementById('timeRankList').innerHTML = listHtml;
            hideAllModals();
            document.getElementById('timeRankModal').classList.remove('hidden');
        }
        
        // Store sorted zones for the modal
        window.sortedZones = [];
        
        // Analyze ALL trades to find best 15-minute time slots sorted by net R
        function renderZoneAnalysis() {
            const summaryEl = document.getElementById('twoTradeSummary');
            
            // Use calculateZonesUpToDay with ALL days
            const zones = calculateZonesUpToDay(days.length - 1);
            
            // Store for modal and other uses
            window.sortedZones = zones;
            
            // Update top 3 times display on calendar pages
            updateTop3TimesDisplay();
            
            // Show top zone in summary (if element exists)
            if (summaryEl) {
                if (zones.length > 0) {
                    const best = zones[0];
                    // Count total trades used in calculation
                    const totalTrades = zones.reduce((max, z) => Math.max(max, z.trades), 0);
                    let allTrades = 0;
                    days.forEach(d => { allTrades += d.trades.length; });
                    summaryEl.innerHTML = `<span class="time">${best.start} - ${best.end}</span> ¬∑ <span class="green">${Math.round(best.winRate)}% win</span><br><span style="font-size:9px;color:#666">${allTrades} total trades analyzed</span>`;
                } else {
                    summaryEl.innerHTML = 'Need more data';
                }
            }
        }
        
        // Update the top 3 times display on calendar pages
        function updateTop3TimesDisplay() {
            const zones = window.sortedZones || [];
            
            [0, 1].forEach(pageNum => {
                const listEl = document.getElementById('top3List' + pageNum);
                if (!listEl) return;
                
                if (zones.length === 0) {
                    listEl.innerHTML = '<div style="color:#666;font-size:10px;text-align:center;width:100%">Need more trade data</div>';
                    return;
                }
                
                // Show top 3 time zones sorted by win rate
                const top3 = zones.slice(0, 3);
                listEl.innerHTML = top3.map((zone, i) => `
                    <div class="top3-item">
                        <div class="top3-rank">#${i + 1}</div>
                        <div class="top3-time">${zone.start}-${zone.end}</div>
                        <div class="top3-winrate green">${Math.round(zone.winRate)}%</div>
                    </div>
                `).join('');
            });
        }
        
        // Show 2-Trade Strategy Modal - shows all 15-min time slots sorted by net R
        function showTwoTradeModal() {
            const zones = window.sortedZones || [];
            if (zones.length === 0) return;
            
            document.getElementById('timeRankTitle').textContent = 'üéØ Best Times (by Win Rate)';
            
            // Helper to parse time to minutes for sorting
            const parseTimeToMinutes = (timeStr) => {
                const parts = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!parts) return 0;
                let h = parseInt(parts[1]);
                const m = parseInt(parts[2]);
                const ampm = parts[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                return h * 60 + m;
            };
            
            // Add original rank to each zone, then sort by time for display
            const zonesWithRank = zones.slice(0, 20).map((zone, i) => ({
                ...zone,
                rank: i + 1
            }));
            
            // Sort by start time (earliest first) for display
            zonesWithRank.sort((a, b) => parseTimeToMinutes(a.start) - parseTimeToMinutes(b.start));
            
            const listHtml = zonesWithRank.map((zone) => {
                const isGood = zone.winRate >= 50;
                const isTop3 = zone.rank <= 3;
                return `<div class="time-rank-item ${isGood ? 'positive' : 'negative'} ${isTop3 ? 'top3' : ''}">
                    <div class="time-rank-pos ${isTop3 ? 'top3' : ''}">#${zone.rank}</div>
                    <div class="time-rank-time">${zone.start} - ${zone.end}</div>
                    <div>
                        <div class="time-rank-r ${isGood ? 'green' : 'red'}" style="font-size:14px">${Math.round(zone.winRate)}% win</div>
                        <div class="time-rank-details"><span class="green">+${zone.greenR.toFixed(0)}R</span> / <span class="red">-${zone.redR.toFixed(0)}R</span> ¬∑ ${zone.trades} trades</div>
                    </div>
                </div>`;
            }).join('');
            
            document.getElementById('timeRankList').innerHTML = listHtml;
            hideAllModals();
            document.getElementById('timeRankModal').classList.remove('hidden');
        }
        
        // Render Calendar Heatmap
        function renderCalendarHeatmap() {
            const container = document.getElementById('calendarHeatmap');
            if (!container) return;
            
            let html = '';
            
            // 10 weeks, 5 days each
            for (let w = 0; w < 10; w++) {
                html += `<div class="heatmap-row">
                    <div class="heatmap-label">W${w + 1}</div>
                    <div class="heatmap-cells">`;
                
                for (let d = 0; d < 5; d++) {
                    const dayIndex = w * 5 + d;
                    const day = days[dayIndex];
                    const trades = calendarShowAll ? day.trades : day.trades.filter(t => t.taken);
                    const r = trades.reduce((sum, t) => sum + t.r, 0);
                    const tradeCount = trades.length;
                    
                    let heatClass = '';
                    if (tradeCount > 0) {
                        if (r >= 4) heatClass = 'w4';
                        else if (r >= 2) heatClass = 'w3';
                        else if (r >= 1) heatClass = 'w2';
                        else if (r > 0) heatClass = 'w1';
                        else if (r === 0) heatClass = '';
                        else if (r >= -1) heatClass = 'l1';
                        else if (r >= -2) heatClass = 'l2';
                        else if (r >= -4) heatClass = 'l3';
                        else heatClass = 'l4';
                    }
                    
                    html += `<div class="heatmap-cell ${heatClass}" title="Day ${dayIndex + 1}: ${r > 0 ? '+' : ''}${r.toFixed(1)}R (${tradeCount} trades)" onclick="openMenuModal(${dayIndex})"></div>`;
                }
                
                html += `</div></div>`;
            }
            
            // Legend
            html += `<div class="heatmap-legend">
                <div class="heatmap-legend-item"><div class="heatmap-legend-box" style="background:#dc2626"></div>-4R</div>
                <div class="heatmap-legend-item"><div class="heatmap-legend-box" style="background:rgba(239,68,68,0.45)"></div>-2R</div>
                <div class="heatmap-legend-item"><div class="heatmap-legend-box" style="background:rgba(255,255,255,0.05)"></div>0</div>
                <div class="heatmap-legend-item"><div class="heatmap-legend-box" style="background:rgba(34,197,94,0.45)"></div>+2R</div>
                <div class="heatmap-legend-item"><div class="heatmap-legend-box" style="background:#22c55e"></div>+4R</div>
            </div>`;
            
            container.innerHTML = html;
        }
        
        // Render Duration vs R-Multiple Scatter Plot
        function renderScatterPlot() {
            const canvas = document.getElementById('scatterCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { top: 15, right: 15, bottom: 55, left: 35 };
            
            // Collect trades with duration (convert to candles - 15 sec per candle)
            const trades = [];
            days.forEach(d => {
                d.trades.forEach(t => {
                    if ((calendarShowAll || t.taken) && (t.candles || (t.duration && t.duration > 0))) {
                        const candles = t.candles || Math.round(t.duration / 15);
                        trades.push({ ...t, candles });
                    }
                });
            });
            
            // Clear
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(0, 0, width, height);
            
            if (trades.length === 0) {
                ctx.fillStyle = '#555';
                ctx.font = '11px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('Add candles to trades to see analysis', width / 2, height / 2);
                return;
            }
            
            const maxCandles = Math.max(...trades.map(t => t.candles), 4);
            const maxR = Math.max(...trades.map(t => Math.abs(t.r)), 2);
            
            const graphWidth = width - padding.left - padding.right;
            const graphHeight = height - padding.top - padding.bottom;
            const zeroY = padding.top + graphHeight / 2;
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            
            // Vertical grid lines for each candle
            for (let c = 1; c <= maxCandles; c++) {
                const x = padding.left + (c / maxCandles) * graphWidth;
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, padding.top + graphHeight);
                ctx.stroke();
            }
            
            // Zero line (thicker)
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.moveTo(padding.left, zeroY);
            ctx.lineTo(width - padding.right, zeroY);
            ctx.stroke();
            
            // Y axis
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + graphHeight);
            ctx.stroke();
            
            // Y axis labels (R values)
            ctx.fillStyle = '#666';
            ctx.font = '9px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('+' + maxR + 'R', padding.left - 4, padding.top + 8);
            ctx.fillText('0', padding.left - 4, zeroY + 3);
            ctx.fillText('-' + maxR + 'R', padding.left - 4, padding.top + graphHeight);
            
            // X axis labels (candles)
            ctx.textAlign = 'center';
            for (let c = 0; c <= maxCandles; c++) {
                const x = padding.left + (c / maxCandles) * graphWidth;
                ctx.fillStyle = '#666';
                ctx.fillText(c + '', x, padding.top + graphHeight + 12);
            }
            ctx.fillText('candles üïØÔ∏è', padding.left + graphWidth / 2, padding.top + graphHeight + 24);
            
            // Plot each trade as a dot
            trades.forEach(t => {
                const x = padding.left + (t.candles / maxCandles) * graphWidth;
                const y = zeroY - (t.r / maxR) * (graphHeight / 2);
                
                // Draw dot with glow effect
                const isWin = t.r > 0;
                const dotSize = Math.min(6, 3 + Math.abs(t.r));
                
                // Glow
                ctx.beginPath();
                ctx.arc(x, y, dotSize + 2, 0, Math.PI * 2);
                ctx.fillStyle = isWin ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
                ctx.fill();
                
                // Main dot
                ctx.beginPath();
                ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                ctx.fillStyle = isWin ? 'rgba(34,197,94,0.8)' : 'rgba(239,68,68,0.8)';
                ctx.fill();
                
                // Border
                ctx.strokeStyle = isWin ? '#22c55e' : '#ef4444';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
            
            // Group trades by R value and calculate average candles
            const rGroups = {};
            trades.forEach(t => {
                const rKey = t.r;
                if (!rGroups[rKey]) {
                    rGroups[rKey] = { r: rKey, candles: [], count: 0 };
                }
                rGroups[rKey].candles.push(t.candles);
                rGroups[rKey].count++;
            });
            
            // Calculate averages
            Object.values(rGroups).forEach(g => {
                g.avgCandles = (g.candles.reduce((a, b) => a + b, 0) / g.candles.length).toFixed(1);
            });
            
            // Sort by R value (highest first)
            const sortedGroups = Object.values(rGroups).sort((a, b) => b.r - a.r);
            
            // Draw summary box at bottom
            const boxY = padding.top + graphHeight + 32;
            const boxHeight = 18;
            
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            ctx.fillRect(padding.left, boxY, graphWidth, boxHeight);
            
            // Show average candles for each R value
            const groupsToShow = sortedGroups.slice(0, 5); // Show top 5
            const groupWidth = graphWidth / groupsToShow.length;
            
            groupsToShow.forEach((g, i) => {
                const x = padding.left + i * groupWidth + groupWidth / 2;
                const isPositive = g.r > 0;
                
                ctx.font = 'bold 9px monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = isPositive ? '#22c55e' : (g.r < 0 ? '#ef4444' : '#888');
                ctx.fillText(`${g.r > 0 ? '+' : ''}${g.r}R: ${g.avgCandles}üïØÔ∏è`, x, boxY + 12);
            });
        }
        
        // Render Entry Time Distribution
        function renderEntryDistribution() {
            const container = document.getElementById('entryDist');
            if (!container) return;
            
            // Group by hour
            const hourData = {};
            for (let h = 9; h <= 16; h++) {
                hourData[h] = { wins: 0, losses: 0 };
            }
            
            days.forEach(d => {
                d.trades.forEach(t => {
                    if (calendarShowAll || t.taken) {
                        const match = t.time.match(/(\d+):(\d+)\s*(AM|PM)/i);
                        if (match) {
                            let hour = parseInt(match[1]);
                            const ampm = match[3].toUpperCase();
                            if (ampm === 'PM' && hour !== 12) hour += 12;
                            if (ampm === 'AM' && hour === 12) hour = 0;
                            
                            if (hourData[hour]) {
                                if (t.r > 0) hourData[hour].wins++;
                                else hourData[hour].losses++;
                            }
                        }
                    }
                });
            });
            
            const maxTotal = Math.max(...Object.values(hourData).map(d => d.wins + d.losses), 1);
            
            let html = '';
            for (let h = 9; h <= 16; h++) {
                const data = hourData[h];
                const winHeight = (data.wins / maxTotal) * 55;
                const lossHeight = (data.losses / maxTotal) * 55;
                const label = h > 12 ? `${h - 12}p` : h === 12 ? '12p' : `${h}a`;
                
                html += `<div class="entry-bar">
                    <div class="entry-bar-stack" style="height:55px;">
                        <div class="entry-bar-win" style="height:${winHeight}px;"></div>
                        <div class="entry-bar-loss" style="height:${lossHeight}px;"></div>
                    </div>
                    <div class="entry-bar-label">${label}</div>
                </div>`;
            }
            
            container.innerHTML = html;
        }
        
        // Render First Trade of Day Analysis
        function renderFirstTradeOfDay() {
            const container = document.getElementById('firstTradeAnalysis');
            if (!container) return;
            
            // Helper to parse time for sorting and get minutes since midnight
            const parseTime = (t) => {
                const timeStr = t.entryTime || t.time || '12:00 PM';
                const parts = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!parts) return 0;
                let h = parseInt(parts[1]);
                const m = parseInt(parts[2]);
                const ampm = parts[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                return h * 60 + m;
            };
            
            // Helper to format minutes back to time string
            const formatTime = (minutes) => {
                let h = Math.floor(minutes / 60);
                const m = minutes % 60;
                const ampm = h >= 12 ? 'PM' : 'AM';
                if (h > 12) h -= 12;
                if (h === 0) h = 12;
                return h + ':' + m.toString().padStart(2, '0') + ' ' + ampm;
            };
            
            // Get first trade of each day with time info
            const firstTrades = [];
            days.forEach((d, dayIndex) => {
                const relevantTrades = calendarShowAll ? d.trades : d.trades.filter(t => t.taken);
                if (relevantTrades.length > 0) {
                    // Sort by time and get the first one
                    const sorted = [...relevantTrades].sort((a, b) => parseTime(a) - parseTime(b));
                    const firstTrade = sorted[0];
                    firstTrades.push({ 
                        ...firstTrade, 
                        dayIndex,
                        timeMinutes: parseTime(firstTrade),
                        timeStr: firstTrade.entryTime || firstTrade.time
                    });
                }
            });
            
            if (firstTrades.length === 0) {
                container.innerHTML = '<div style="text-align:center;padding:20px;color:#444;font-size:11px;">No trades yet</div>';
                return;
            }
            
            // Calculate stats
            const wins = firstTrades.filter(t => t.r > 0).length;
            const losses = firstTrades.filter(t => t.r < 0).length;
            const breakeven = firstTrades.filter(t => t.r === 0).length;
            const totalR = firstTrades.reduce((sum, t) => sum + t.r, 0);
            const winRate = Math.round((wins / firstTrades.length) * 100);
            const avgR = (totalR / firstTrades.length).toFixed(2);
            
            // Calculate average first trade time
            const avgTimeMinutes = Math.round(firstTrades.reduce((sum, t) => sum + t.timeMinutes, 0) / firstTrades.length);
            const avgTimeStr = formatTime(avgTimeMinutes);
            
            // Find most common first trade time (rounded to 15 min)
            const timeBuckets = {};
            firstTrades.forEach(t => {
                const bucket = Math.floor(t.timeMinutes / 15) * 15;
                if (!timeBuckets[bucket]) {
                    timeBuckets[bucket] = { wins: 0, losses: 0, totalR: 0, count: 0 };
                }
                timeBuckets[bucket].count++;
                timeBuckets[bucket].totalR += t.r;
                if (t.r > 0) timeBuckets[bucket].wins++;
                else timeBuckets[bucket].losses++;
            });
            
            // Find best time to start (highest R among times with 2+ trades)
            let bestTime = null;
            let bestTimeR = -Infinity;
            let bestTimeWinRate = 0;
            Object.entries(timeBuckets).forEach(([minutes, data]) => {
                if (data.count >= 2 && data.totalR > bestTimeR) {
                    bestTime = parseInt(minutes);
                    bestTimeR = data.totalR;
                    bestTimeWinRate = Math.round((data.wins / data.count) * 100);
                }
            });
            
            // Find worst time
            let worstTime = null;
            let worstTimeR = Infinity;
            Object.entries(timeBuckets).forEach(([minutes, data]) => {
                if (data.count >= 2 && data.totalR < worstTimeR) {
                    worstTime = parseInt(minutes);
                    worstTimeR = data.totalR;
                }
            });
            
            // Build insight message
            let insight = '';
            let insightClass = 'neutral';
            
            if (bestTime !== null && worstTime !== null && bestTime !== worstTime) {
                if (avgTimeMinutes <= worstTime + 15 && bestTime > avgTimeMinutes) {
                    insight = `‚ö†Ô∏è You usually start at ${avgTimeStr}, but your best results come at ${formatTime(bestTime)} (${bestTimeWinRate}% win). Try waiting ${Math.round((bestTime - avgTimeMinutes) / 15) * 15} minutes longer.`;
                    insightClass = winRate < 50 ? 'negative' : 'neutral';
                } else if (winRate >= 60) {
                    insight = `üî• Strong first trades! You start around ${avgTimeStr} and win ${winRate}% of the time.`;
                    insightClass = 'positive';
                } else if (winRate >= 50) {
                    insight = `üìä Decent start at ${avgTimeStr}. Best results at ${formatTime(bestTime)} (${bestTimeWinRate}% win).`;
                    insightClass = 'neutral';
                } else {
                    insight = `üö® First trades at ${avgTimeStr} are losing (${winRate}% win). Consider waiting until ${formatTime(bestTime)} instead.`;
                    insightClass = 'negative';
                }
            } else if (winRate >= 60) {
                insight = `üî• Your first trades at ${avgTimeStr} are solid! Keep it up.`;
                insightClass = 'positive';
            } else if (winRate >= 50) {
                insight = `üìä Average start at ${avgTimeStr}. Need more data to find optimal time.`;
                insightClass = 'neutral';
            } else {
                insight = `‚ö†Ô∏è First trades at ${avgTimeStr} are weak (${winRate}% win). Try waiting 5-10 min longer.`;
                insightClass = 'negative';
            }
            
            const isPositiveR = totalR >= 0;
            
            let html = '<div class="first-trade-stats">';
            html += '<div class="first-trade-stat"><div class="first-trade-stat-value" style="color:#888">' + avgTimeStr + '</div><div class="first-trade-stat-label">Avg Start</div></div>';
            html += '<div class="first-trade-stat highlight' + (winRate < 50 ? ' negative' : '') + '"><div class="first-trade-stat-value ' + (winRate >= 50 ? 'green' : 'red') + '">' + winRate + '%</div><div class="first-trade-stat-label">Win Rate</div></div>';
            html += '<div class="first-trade-stat"><div class="first-trade-stat-value ' + (isPositiveR ? 'green' : 'red') + '">' + (totalR > 0 ? '+' : '') + totalR.toFixed(1) + 'R</div><div class="first-trade-stat-label">Total R</div></div>';
            html += '</div>';
            
            // Show best time if found
            if (bestTime !== null) {
                html += '<div style="display:flex;gap:12px;justify-content:center;font-size:10px;margin:8px 0;">';
                html += '<span style="color:#666">Best start: <span class="green" style="font-weight:600">' + formatTime(bestTime) + '</span> (' + bestTimeWinRate + '% win)</span>';
                html += '</div>';
            }
            
            html += '<div style="display:flex;gap:8px;justify-content:center;font-size:10px;color:#666;">';
            html += '<span><span class="green">' + wins + '</span> W</span>';
            html += '<span><span class="red">' + losses + '</span> L</span>';
            html += '<span>' + firstTrades.length + ' days</span>';
            html += '</div>';
            
            html += '<div class="first-trade-insight ' + insightClass + '">' + insight + '</div>';
            
            container.innerHTML = html;
        }
        
        // Render all analytics (page removed - function kept as stub)
        function renderAnalytics() {
            // Analytics page was removed
        }
        
        // ============ END ANALYTICS ============
        
        // Update UI
        function updateStats() {
            const s = calcStats();
            
            // Calculate Best 2 stats if in that mode
            let count, wins, losses, totalR;
            
            if (calendarMode === 'best2') {
                // Calculate stats from best 2 trades per day
                count = 0;
                wins = 0;
                losses = 0;
                totalR = 0;
                for (let i = 0; i < days.length; i++) {
                    const best2 = getBest2TradesForDay(i);
                    best2.forEach(t => {
                        count++;
                        totalR += t.r;
                        if (t.r > 0) wins++;
                        else if (t.r < 0) losses++;
                    });
                }
            } else if (calendarShowAll) {
                count = s.allCount;
                wins = s.allWins;
                losses = s.allLosses;
                totalR = s.allR;
            } else {
                count = s.myCount;
                wins = s.myWins;
                losses = s.myLosses;
                totalR = s.myR;
            }
            
            document.getElementById('statTrades').textContent = count;
            document.getElementById('statWins').textContent = wins;
            document.getElementById('statLosses').textContent = losses;
            
            // Win Rate
            const winRate = count > 0 ? Math.round((wins / count) * 100) : 0;
            const winRateEl = document.getElementById('statWinRate');
            winRateEl.textContent = winRate + '%';
            winRateEl.className = 'stat-value ' + (winRate >= 50 ? 'green' : 'red');
            
            const rEl = document.getElementById('statR');
            rEl.textContent = (totalR > 0 ? '+' : '') + totalR.toFixed(1);
            rEl.className = 'stat-value ' + (totalR >= 0 ? 'green' : 'red');
            document.getElementById('statBalance').textContent = '$' + startingBalance.toLocaleString();
            
            // Balance display - show best2 balance if in that mode
            const realBal = startingBalance * (1 + s.myR * 0.05);
            const setupsBal = startingBalance * (1 + s.allR * 0.05);
            const best2Bal = startingBalance * (1 + totalR * 0.05);
            
            const realEl = document.getElementById('realBalance');
            const setupsEl = document.getElementById('setupsBalance');
            
            if (calendarMode === 'best2') {
                realEl.textContent = '$' + Math.round(best2Bal).toLocaleString() + ' (' + (totalR >= 0 ? '+' : '') + (totalR * 5).toFixed(0) + '%)';
                realEl.className = 'balance-value ' + (best2Bal >= startingBalance ? 'green' : 'red');
                setupsEl.textContent = '$' + Math.round(realBal).toLocaleString() + ' (' + (s.myR >= 0 ? '+' : '') + (s.myR * 5).toFixed(0) + '%)';
                setupsEl.className = 'balance-value ' + (realBal >= startingBalance ? 'green' : 'red');
                document.querySelector('.balance-box:first-child .balance-label').textContent = 'Best 2';
                document.querySelector('.balance-box:last-child .balance-label').textContent = 'Actual';
            } else {
                realEl.textContent = '$' + Math.round(realBal).toLocaleString() + ' (' + (s.myR >= 0 ? '+' : '') + (s.myR * 5).toFixed(0) + '%)';
                setupsEl.textContent = '$' + Math.round(setupsBal).toLocaleString() + ' (' + (s.allR >= 0 ? '+' : '') + (s.allR * 5).toFixed(0) + '%)';
                realEl.className = 'balance-value ' + (realBal >= startingBalance ? 'green' : 'red');
                setupsEl.className = 'balance-value ' + (setupsBal >= startingBalance ? 'green' : 'red');
                document.querySelector('.balance-box:first-child .balance-label').textContent = 'Real';
                document.querySelector('.balance-box:last-child .balance-label').textContent = 'Setups';
            }
            
            // Progress bar - count days with trades based on mode
            let daysWithTrades;
            if (calendarMode === 'best2') {
                daysWithTrades = days.filter(d => d.trades.length > 0).length;
            } else if (calendarShowAll) {
                daysWithTrades = days.filter(d => d.trades.length > 0).length;
            } else {
                daysWithTrades = days.filter(d => d.trades.some(t => t.taken)).length;
            }
            document.getElementById('progressDays').textContent = daysWithTrades + '/365 days';
            document.getElementById('progressBar').style.width = (daysWithTrades / 365 * 100) + '%';
            
            // Daily goal - get current day (most recent day with trades based on toggle)
            let currentDayR = 0;
            for (let i = days.length - 1; i >= 0; i--) {
                const hasTrades = calendarShowAll ? days[i].trades.length > 0 : days[i].trades.some(t => t.taken);
                if (hasTrades) {
                    const trades = calendarShowAll ? days[i].trades : days[i].trades.filter(t => t.taken);
                    currentDayR = trades.reduce((sum, t) => sum + t.r, 0);
                    break;
                }
            }
            const dailyCurrent = document.getElementById('dailyGoalCurrent');
            dailyCurrent.textContent = (currentDayR >= 0 ? '+' : '') + currentDayR.toFixed(1);
            dailyCurrent.className = 'goal-current' + (currentDayR < dailyGoal ? ' behind' : '');
            document.getElementById('dailyGoalTarget').textContent = dailyGoal + 'R';
            document.getElementById('dailyGoalBtn').className = 'goal-box' + (currentDayR >= dailyGoal ? ' achieved' : '');
            
            // Weekly goal - get current week's R based on toggle
            const currentWeekIndex = Math.floor((daysWithTrades > 0 ? daysWithTrades - 1 : 0) / 5);
            const weekData = calcWeek(currentWeekIndex);
            const weeklyR = calendarShowAll ? weekData.allR : weekData.myR;
            const weeklyCurrent = document.getElementById('weeklyGoalCurrent');
            weeklyCurrent.textContent = (weeklyR >= 0 ? '+' : '') + weeklyR.toFixed(1);
            weeklyCurrent.className = 'goal-current' + (weeklyR < weeklyGoal ? ' behind' : '');
            document.getElementById('weeklyGoalTarget').textContent = weeklyGoal + 'R';
            document.getElementById('weeklyGoalBtn').className = 'goal-box' + (weeklyR >= weeklyGoal ? ' achieved' : '');
            
            // Prediction accuracy
            const predAccuracy = calculatePredictionAccuracy();
            const predEl = document.getElementById('predictionAccuracy');
            predEl.textContent = `${predAccuracy.correct}/${predAccuracy.total} (${predAccuracy.pct}%)`;
            predEl.className = 'balance-value ' + (predAccuracy.pct >= 60 ? 'green' : (predAccuracy.pct >= 40 ? '' : 'red'));
        }
        
        // Helper: Get ranked time slots based on all trades
        function getRankedTimeSlots() {
            // This is now only used as a fallback
            const timeSlots = {};
            
            days.forEach(d => {
                d.trades.forEach(t => {
                    if (!timeSlots[t.time]) {
                        timeSlots[t.time] = { time: t.time, greenR: 0, redR: 0, trades: 0, wins: 0 };
                    }
                    timeSlots[t.time].trades++;
                    if (t.r > 0) {
                        timeSlots[t.time].greenR += t.r;
                        timeSlots[t.time].wins++;
                    } else if (t.r < 0) {
                        timeSlots[t.time].redR += Math.abs(t.r);
                    }
                });
            });
            
            const slots = Object.values(timeSlots);
            slots.forEach(s => {
                s.winRate = s.trades > 0 ? (s.wins / s.trades) * 100 : 0;
                s.netR = s.greenR - s.redR;
            });
            
            slots.sort((a, b) => {
                if (b.winRate !== a.winRate) return b.winRate - a.winRate;
                return b.netR - a.netR;
            });
            
            return slots;
        }
        
        // Helper: Get the best 2 trades for a specific day using zone-based ranking
        // Respects prediction: Hot = any zone, Warm = top 3 only, Cold = #1 only
        function getBest2TradesForDay(dayIndex) {
            const dayTrades = days[dayIndex].trades;
            
            if (dayTrades.length === 0) return [];
            
            // Get prediction for this day (based on previous day)
            let maxAllowedRank = 999; // Default: all zones (hot prediction)
            let predictionType = 'hot';
            
            if (dayIndex > 0) {
                const prediction = predictNextDay(dayIndex - 1);
                if (prediction) {
                    predictionType = prediction.prediction;
                    if (prediction.prediction === 'cold') {
                        // SITOUT day: return NO trades - shouldn't trade this day
                        return [];
                    }
                    // For warm days, we'll filter by 70% win rate below
                }
            }
            
            // Use CURRENT best times (from graph) - same for all days
            const zones = window.sortedZones || [];
            
            if (zones.length === 0) {
                // No data yet - return first 2 trades
                return dayTrades.slice(0, 2);
            }
            
            // Helper to parse time to minutes
            const parseTimeToMinutes = (timeStr) => {
                const parts = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!parts) return 0;
                let h = parseInt(parts[1]);
                const m = parseInt(parts[2]);
                const ampm = parts[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                return h * 60 + m;
            };
            
            // 5 AM = 300 minutes (earliest trading time)
            const earliestTradeTime = 300;
            
            // Filter day's trades to only those at 5 AM or later
            const validDayTrades = dayTrades.filter(t => parseTimeToMinutes(t.time) >= earliestTradeTime);
            
            if (validDayTrades.length === 0) return [];
            
            // For warm days, only allow trades in zones with 70%+ win rate
            // For hot days, allow any zone
            const minWinRate = predictionType === 'warm' ? 70 : 0;
            
            // For each trade, find which zone it's in and check win rate
            const tradesWithZone = validDayTrades.map(trade => {
                const tradeMin = parseTimeToMinutes(trade.time);
                let bestZone = null;
                let bestRank = 9999;
                
                // Find the highest-ranked zone (lowest number) this trade falls into
                for (let i = 0; i < zones.length; i++) {
                    const zone = zones[i];
                    const zoneStart = parseTimeToMinutes(zone.start);
                    const zoneEnd = parseTimeToMinutes(zone.end);
                    
                    if (tradeMin >= zoneStart && tradeMin <= zoneEnd) {
                        // This trade is in zone rank (i + 1)
                        if (i + 1 < bestRank) {
                            bestRank = i + 1;
                            bestZone = zone;
                        }
                    }
                }
                
                return { trade, bestRank, bestZone };
            });
            
            // Filter to only trades in zones with win rate >= minWinRate
            const allowedTrades = tradesWithZone.filter(t => {
                if (!t.bestZone) return false; // Not in any zone
                return t.bestZone.winRate >= minWinRate;
            });
            
            // Sort by rank (best first), then return up to 2
            allowedTrades.sort((a, b) => a.bestRank - b.bestRank);
            
            return allowedTrades.slice(0, 2).map(t => t.trade);
        }
        
        // Calculate best time ZONES (consecutive 15-min ranges) sorted by win rate
        // This is the ONLY calculation used everywhere
        // ONLY includes trades between 5:00 AM and 8:00 AM
        function calculateZonesUpToDay(maxDayIndex) {
            if (maxDayIndex < 0) return [];
            
            const timeSlots = {};
            
            // Helper to parse time to minutes
            const parseTimeToMinutes = (timeStr) => {
                const parts = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                if (!parts) return 0;
                let h = parseInt(parts[1]);
                const m = parseInt(parts[2]);
                const ampm = parts[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                return h * 60 + m;
            };
            
            // Format minutes back to time string
            const formatTime = (mins) => {
                let hr = Math.floor(mins / 60);
                const mn = mins % 60;
                const ap = hr >= 12 ? 'PM' : 'AM';
                if (hr > 12) hr -= 12;
                if (hr === 0) hr = 12;
                return hr + ':' + mn.toString().padStart(2, '0') + ' ' + ap;
            };
            
            // Time range: 5:00 AM (300 mins) to 8:00 AM (480 mins)
            const minTime = 300; // 5:00 AM
            const maxTime = 480; // 8:00 AM
            
            // Collect all trades up to maxDayIndex into 15-min buckets
            for (let d = 0; d <= maxDayIndex && d < days.length; d++) {
                days[d].trades.forEach(t => {
                    const tradeMinutes = parseTimeToMinutes(t.time);
                    
                    // Only include trades between 5 AM and 8 AM
                    if (tradeMinutes < minTime || tradeMinutes >= maxTime) return;
                    
                    // Get the 15-min bucket
                    const bucketStart = Math.floor(tradeMinutes / 15) * 15;
                    const bucketKey = bucketStart;
                    
                    if (!timeSlots[bucketKey]) {
                        timeSlots[bucketKey] = { 
                            bucketStart, 
                            time: formatTime(bucketStart),
                            greenR: 0, 
                            redR: 0, 
                            trades: 0, 
                            wins: 0 
                        };
                    }
                    timeSlots[bucketKey].trades++;
                    if (t.r > 0) {
                        timeSlots[bucketKey].greenR += t.r;
                        timeSlots[bucketKey].wins++;
                    } else if (t.r < 0) {
                        timeSlots[bucketKey].redR += Math.abs(t.r);
                    }
                });
            }
            
            // Convert to array and sort by time
            const slots = Object.values(timeSlots);
            slots.sort((a, b) => a.bucketStart - b.bucketStart);
            
            if (slots.length < 1) return [];
            
            // Build zones from consecutive time slots (windows of 1-4 slots = 15min to 1hr)
            const zones = [];
            for (let windowSize = 1; windowSize <= Math.min(4, slots.length); windowSize++) {
                for (let i = 0; i <= slots.length - windowSize; i++) {
                    const windowSlots = slots.slice(i, i + windowSize);
                    
                    // Check if slots are consecutive (each 15 mins apart)
                    let isConsecutive = true;
                    for (let j = 1; j < windowSlots.length; j++) {
                        if (windowSlots[j].bucketStart - windowSlots[j-1].bucketStart !== 15) {
                            isConsecutive = false;
                            break;
                        }
                    }
                    if (!isConsecutive) continue;
                    
                    const greenR = windowSlots.reduce((sum, s) => sum + s.greenR, 0);
                    const redR = windowSlots.reduce((sum, s) => sum + s.redR, 0);
                    const netR = greenR - redR;
                    const trades = windowSlots.reduce((sum, s) => sum + s.trades, 0);
                    const wins = windowSlots.reduce((sum, s) => sum + s.wins, 0);
                    const winRate = trades > 0 ? (wins / trades) * 100 : 0;
                    
                    // Calculate end time (last bucket start + 14 mins)
                    const startTime = formatTime(windowSlots[0].bucketStart);
                    const endTime = formatTime(windowSlots[windowSlots.length - 1].bucketStart + 14);
                    
                    zones.push({
                        start: startTime,
                        end: endTime,
                        greenR,
                        redR,
                        netR,
                        trades,
                        wins,
                        winRate
                    });
                }
            }
            
            // Sort by WIN RATE (highest first), then net R as tiebreaker
            zones.sort((a, b) => {
                if (b.winRate !== a.winRate) return b.winRate - a.winRate;
                return b.netR - a.netR;
            });
            
            return zones;
        }
        
        // Get actual result for a day (hot/warm/cold)
        function getActualResult(dayIndex) {
            if (dayIndex < 0 || dayIndex >= days.length) return null;
            
            const dayTrades = days[dayIndex].trades;
            if (dayTrades.length === 0) return null;
            
            const dr = dayTrades.reduce((s, t) => s + t.r, 0);
            const tc = dayTrades.length;
            const expectedR = tc;
            
            if (dr >= expectedR) return 'hot';
            else if (dr >= expectedR * 0.5) return 'warm';
            else return 'cold';
        }
        
        // Get win rate for a day
        function getDayWinRate(dayIndex) {
            if (dayIndex < 0 || dayIndex >= days.length) return null;
            
            const dayTrades = days[dayIndex].trades;
            if (dayTrades.length === 0) return null;
            
            const wins = dayTrades.filter(t => t.r > 0).length;
            return Math.round((wins / dayTrades.length) * 100);
        }
        
        // Predict next day based on actual results and win rate trends
        function predictNextDay(prevDayIndex) {
            if (prevDayIndex < 0 || prevDayIndex >= days.length) return null;
            
            const prevDay = days[prevDayIndex];
            const prevTrades = prevDay.trades;
            
            if (prevTrades.length === 0) return null;
            
            // Get previous day's stats
            const prevWinRate = getDayWinRate(prevDayIndex);
            const prevActual = getActualResult(prevDayIndex);
            
            // Get day before that (handles Friday‚ÜíMonday by just going back 1 index)
            const beforeWinRate = getDayWinRate(prevDayIndex - 1);
            const beforeActual = getActualResult(prevDayIndex - 1);
            
            // Calculate win rate trend (how much did it drop/rise?)
            let winRateTrend = 0; // positive = rising, negative = dropping
            if (beforeWinRate !== null) {
                winRateTrend = prevWinRate - beforeWinRate;
            }
            
            // Check if we're predicting for Monday (first day of a week)
            const predictingForDayIndex = prevDayIndex + 1;
            const isMonday = (predictingForDayIndex % 5) === 0;
            
            // Week momentum - compare Monday vs Tuesday of current week
            // But if predicting Monday, look at LAST week's trend instead
            let weekMomentum = 0;
            
            if (isMonday && prevDayIndex >= 4) {
                // Predicting Monday - look at how last week ended
                // Compare last week's Thursday vs Friday
                const lastFriday = prevDayIndex; // prevDay IS Friday
                const lastThursday = prevDayIndex - 1;
                const thuWinRate = getDayWinRate(lastThursday);
                const friWinRate = getDayWinRate(lastFriday);
                
                if (thuWinRate !== null && friWinRate !== null) {
                    if (friWinRate > thuWinRate + 5) weekMomentum = 1; // Week ended heating up
                    else if (friWinRate < thuWinRate - 5) weekMomentum = -1; // Week ended cooling
                }
                
                // Also factor in overall last week trend (Monday vs Friday)
                const lastMonday = Math.floor(prevDayIndex / 5) * 5;
                const monWinRate = getDayWinRate(lastMonday);
                if (monWinRate !== null && friWinRate !== null) {
                    if (friWinRate < monWinRate - 10) {
                        // Week dropped significantly from Monday to Friday
                        weekMomentum = -1;
                    } else if (friWinRate > monWinRate + 10) {
                        // Week improved from Monday to Friday
                        weekMomentum = 1;
                    }
                }
            } else {
                // Normal mid-week - compare Monday vs Tuesday
                const weekStart = Math.floor(prevDayIndex / 5) * 5;
                if (weekStart + 1 < days.length) {
                    const monWinRate = getDayWinRate(weekStart);
                    const tueWinRate = getDayWinRate(weekStart + 1);
                    if (monWinRate !== null && tueWinRate !== null) {
                        if (tueWinRate > monWinRate + 5) weekMomentum = 1; // Heating
                        else if (tueWinRate < monWinRate - 5) weekMomentum = -1; // Cooling
                    }
                }
            }
            
            // PREDICTION LOGIC based on ACTUAL RESULTS and WIN RATE TRENDS
            let prediction;
            
            // Pattern: 2 COLD days in a row with decent win rates = cold streak ending
            if (prevActual === 'cold' && beforeActual === 'cold') {
                // Two cold days in a row
                if (prevWinRate >= 55 && beforeWinRate >= 55) {
                    // But win rates are still decent - cold streak running out of steam
                    if (winRateTrend >= -5) {
                        // Small drop or stable = warming up
                        prediction = 'warm';
                    } else {
                        // Big drop = still getting colder
                        prediction = 'cold';
                    }
                } else if (prevWinRate < 45) {
                    // Win rate is actually bad = stay cold
                    prediction = 'cold';
                } else {
                    // Medium win rate after 2 cold days = could go warm
                    prediction = winRateTrend >= 0 ? 'warm' : 'cold';
                }
            }
            // Pattern: 2 HOT days in a row = might cool off
            else if (prevActual === 'hot' && beforeActual === 'hot') {
                if (winRateTrend >= 0) {
                    // Still rising or stable = stay hot
                    prediction = 'hot';
                } else if (winRateTrend >= -5) {
                    // Small drop = warm
                    prediction = 'warm';
                } else {
                    // Dropping fast = cooling to warm
                    prediction = 'warm';
                }
            }
            // Pattern: HOT then COLD = check the drop
            else if (beforeActual === 'hot' && prevActual === 'cold') {
                // Big swing - use win rate to decide
                if (prevWinRate >= 60) {
                    prediction = 'warm'; // Bad day but good win rate = bounce back
                } else {
                    prediction = 'cold'; // Genuinely cooling off
                }
            }
            // Pattern: COLD then HOT = heating up
            else if (beforeActual === 'cold' && prevActual === 'hot') {
                if (winRateTrend > 0) {
                    prediction = 'hot'; // Momentum continuing
                } else {
                    prediction = 'warm'; // Might stabilize
                }
            }
            // Single day or first comparison - use win rate primarily
            else {
                if (prevWinRate >= 70 && prevActual === 'hot') {
                    prediction = 'hot';
                } else if (prevWinRate >= 60) {
                    prediction = prevActual === 'hot' ? 'hot' : 'warm';
                } else if (prevWinRate >= 50) {
                    prediction = 'warm';
                } else {
                    prediction = 'cold';
                }
            }
            
            // Week momentum can push prediction one way
            if (weekMomentum === 1 && prediction === 'warm') {
                // Week heating up - could be hot
                if (prevWinRate >= 60) prediction = 'hot';
            } else if (weekMomentum === -1 && prediction === 'warm') {
                // Week cooling - lean toward cold
                if (prevWinRate < 55) prediction = 'cold';
            } else if (weekMomentum === -1 && prediction === 'hot') {
                // Week cooling but predicting hot - be cautious
                prediction = 'warm';
            }
            
            // Special case: Predicting Monday after a cold Friday
            if (isMonday && prevActual === 'cold' && prevWinRate < 50) {
                // Friday was genuinely cold - Monday likely cold too
                prediction = 'cold';
            }
            
            return {
                prediction,
                emoji: prediction === 'hot' ? 'üî•' : (prediction === 'warm' ? 'üå§Ô∏è' : 'ü•∂'),
                prevWinRate,
                prevActual,
                beforeWinRate,
                beforeActual,
                winRateTrend,
                weekMomentum,
                isMonday
            };
        }
        
        // Calculate prediction accuracy
        function calculatePredictionAccuracy() {
            let correct = 0;
            let total = 0;
            
            for (let i = 1; i < days.length; i++) {
                const prediction = predictNextDay(i - 1);
                const actual = getActualResult(i);
                
                // Skip P:SITOUT days - we don't trade those, so they don't count toward accuracy
                if (prediction && prediction.prediction === 'cold') {
                    continue;
                }
                
                if (prediction && actual) {
                    total++;
                    if (prediction.prediction === actual) {
                        correct++;
                    }
                }
            }
            
            return { correct, total, pct: total > 0 ? Math.round((correct / total) * 100) : 0 };
        }
        
        function renderCalendar() {
            // Calculate todayIndex based on mode - last day with relevant trades
            todayIndex = 0;
            for (let i = 0; i < days.length; i++) {
                let hasTrades = false;
                if (calendarMode === 'all') {
                    hasTrades = days[i].trades.length > 0;
                } else if (calendarMode === 'best2') {
                    hasTrades = days[i].trades.length > 0;
                } else {
                    hasTrades = days[i].trades.some(t => t.taken);
                }
                if (hasTrades) {
                    todayIndex = i;
                }
            }
            
            const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
            const totalWeeks = Math.ceil(365 / 5); // 73 weeks
            const weeksPerPage = 5;
            
            // Update week navigation labels
            const startWeek = weekOffset * weeksPerPage + 1;
            const endWeek = Math.min(startWeek + weeksPerPage - 1, totalWeeks);
            [0, 1].forEach(pi => {
                const label = document.getElementById('weekLabel' + pi);
                if (label) label.textContent = 'Weeks ' + startWeek + '-' + endWeek;
            });
            
            [0, 1].forEach(pi => {
                const grid = document.getElementById('grid' + pi);
                if (!grid) return;
                grid.innerHTML = '';
                for (let r = 0; r < weeksPerPage; r++) {
                    const row = document.createElement('div');
                    row.className = 'calendar-row';
                    for (let c = 0; c < 6; c++) {
                        const btn = document.createElement('button');
                        if (c === 5) {
                            // Week box - calculate based on weekOffset
                            const wi = weekOffset * weeksPerPage + r;
                            if (wi >= totalWeeks) {
                                btn.className = 'day-box week empty';
                                btn.innerHTML = '';
                                row.appendChild(btn);
                                continue;
                            }
                            let weekR = 0;
                            let weekCount = 0;
                            let weekWins = 0;
                            for (let wd = 0; wd < 5; wd++) {
                                const dayIdx = wi * 5 + wd;
                                if (dayIdx < days.length) {
                                    // Skip SITOUT days in All Trades and Best 2 modes
                                    if (isDaySitout(dayIdx) && (calendarMode === 'all' || calendarMode === 'best2')) {
                                        continue;
                                    }
                                    
                                    const d = days[dayIdx];
                                    let showTrades;
                                    if (calendarMode === 'all') {
                                        showTrades = d.trades;
                                    } else if (calendarMode === 'best2') {
                                        showTrades = getBest2TradesForDay(dayIdx);
                                    } else {
                                        showTrades = d.trades.filter(t => t.taken);
                                    }
                                    showTrades.forEach(t => {
                                        weekR += t.r;
                                        weekCount++;
                                        if (t.r > 0) weekWins++;
                                    });
                                }
                            }
                            const weekWinRate = weekCount > 0 ? Math.round((weekWins / weekCount) * 100) : 0;
                            const displayLabel = calendarMode === 'all' ? 'ALL' : (calendarMode === 'best2' ? 'B2' : 'WK' + (wi + 1));
                            const weekMoney = startingBalance * weekR * 0.05;
                            btn.className = 'day-box week' + (weekR < 0 ? ' negative' : '');
                            if (calendarMode === 'best2') {
                                btn.innerHTML = `<span class="day-label week">${displayLabel}</span><span class="week-r ${weekR >= 0 ? 'green' : 'red'}">${weekR > 0 ? '+' : ''}${weekR.toFixed(1)}R</span><span class="week-money ${weekWinRate >= 50 ? 'green' : 'red'}">${weekWinRate}%</span>`;
                            } else {
                                btn.innerHTML = `<span class="day-label week">${displayLabel}</span><span class="week-r ${weekR >= 0 ? 'green' : 'red'}">${weekR > 0 ? '+' : ''}${weekR.toFixed(1)}R</span><span class="week-money ${weekMoney >= 0 ? 'green' : 'red'}">${weekMoney >= 0 ? '+' : ''}$${Math.abs(Math.round(weekMoney))}</span>`;
                            }
                            btn.addEventListener('click', () => openWeekModal(wi));
                        } else {
                            // Day box - calculate based on weekOffset
                            const dayIndex = (weekOffset * weeksPerPage + r) * 5 + c;
                            if (dayIndex >= days.length) {
                                btn.className = 'day-box empty';
                                btn.innerHTML = '';
                                row.appendChild(btn);
                                continue;
                            }
                            const d = days[dayIndex];
                            const takenTrades = d.trades.filter(t => t.taken);
                            const allTrades = d.trades;
                            
                            // Get day name based on column (Mon=0, Tue=1, Wed=2, Thu=3, Fri=4)
                            const dayName = dayNames[c];
                            
                            // Show based on mode
                            let showTrades;
                            if (calendarMode === 'all') {
                                showTrades = allTrades;
                            } else if (calendarMode === 'best2') {
                                showTrades = getBest2TradesForDay(dayIndex);
                            } else {
                                showTrades = takenTrades;
                            }
                            
                            const dr = showTrades.reduce((s, t) => s + t.r, 0);
                            const tc = showTrades.length;
                            const totalCount = allTrades.length;
                            
                            // Calculate green and red R and wins
                            let greenR = 0;
                            let redR = 0;
                            let wins = 0;
                            showTrades.forEach(t => {
                                if (t.r > 0) {
                                    greenR += t.r;
                                    wins++;
                                } else if (t.r < 0) {
                                    redR += Math.abs(t.r);
                                }
                            });
                            
                            // Win percentage for this day
                            const dayWinPct = tc > 0 ? Math.round((wins / tc) * 100) : 0;
                            
                            // Calculate hot/warm/cold (actual result)
                            let tempIndicator = '';
                            if (tc > 0) {
                                const expectedR = tc;
                                if (dr >= expectedR) {
                                    tempIndicator = '<span class="temp-badge hot">üî•</span>';
                                } else if (dr >= expectedR * 0.5) {
                                    tempIndicator = '<span class="temp-badge warm">üå§Ô∏è</span>';
                                } else {
                                    tempIndicator = '<span class="temp-badge cold">ü•∂</span>';
                                }
                            }
                            
                            // Prediction emoji (based on previous day)
                            let predictionIndicator = '';
                            if (dayIndex > 0) {
                                const pred = predictNextDay(dayIndex - 1);
                                if (pred) {
                                    predictionIndicator = `<span class="pred-badge">${pred.emoji}</span>`;
                                }
                            }
                            
                            let cls = 'day-box';
                            const isSitoutDay = isDaySitout(dayIndex);
                            
                            // On All Trades or Best 2 tab, P:SITOUT days show as solid gray
                            if (isSitoutDay && (calendarMode === 'all' || calendarMode === 'best2')) {
                                cls += ' sitout';
                            } else if (dr < 0) {
                                cls += ' negative';
                            } else if (tc > 0) {
                                cls += ' has-trades';
                            }
                            if (dayIndex === todayIndex) cls += ' today';
                            btn.className = cls;
                            
                            // Sitout day display (for All Trades and Best 2 modes)
                            if (isSitoutDay && (calendarMode === 'all' || calendarMode === 'best2')) {
                                // Calculate actual result for sitout day (from all trades that day)
                                const sitoutDayTrades = days[dayIndex].trades;
                                let sitoutActual = '';
                                let sitoutWinPct = 0;
                                if (sitoutDayTrades.length > 0) {
                                    const sitoutR = sitoutDayTrades.reduce((s, t) => s + t.r, 0);
                                    const sitoutCount = sitoutDayTrades.length;
                                    const sitoutWins = sitoutDayTrades.filter(t => t.r > 0).length;
                                    sitoutWinPct = Math.round((sitoutWins / sitoutCount) * 100);
                                    if (sitoutR >= sitoutCount) {
                                        sitoutActual = 'üî•';
                                    } else if (sitoutR >= sitoutCount * 0.5) {
                                        sitoutActual = 'üå§Ô∏è';
                                    } else {
                                        sitoutActual = 'ü•∂';
                                    }
                                }
                                const sitoutPctClass = sitoutWinPct >= 60 ? 'green' : (sitoutWinPct >= 40 ? 'yellow' : 'red');
                                if (calendarMode === 'best2') {
                                    // Best 2 mode: just show üí§ and actual result emoji (no percentage)
                                    if (sitoutDayTrades.length > 0) {
                                        btn.innerHTML = `<span class="sitout-label">üí§</span>${sitoutActual ? `<span class="sitout-actual">${sitoutActual}</span>` : ''}`;
                                    } else {
                                        btn.innerHTML = `<span class="sitout-label">üí§ SKIP</span>`;
                                    }
                                } else {
                                    // All Trades mode: show percentage
                                    if (sitoutDayTrades.length > 0) {
                                        btn.innerHTML = `<span class="sitout-label">üí§</span><span class="day-pct ${sitoutPctClass}">${sitoutWinPct}%</span>${sitoutActual ? `<span class="sitout-actual">${sitoutActual}</span>` : ''}`;
                                    } else {
                                        btn.innerHTML = `<span class="sitout-label">üí§ SKIP</span>`;
                                    }
                                }
                            } else if (tc > 0) {
                                // Has trades - show based on mode
                                if (calendarMode === 'best2') {
                                    // Best 2 mode: show R value instead of percentage
                                    const rClass = dr >= 0 ? 'green' : 'red';
                                    const rDisplay = (dr >= 0 ? '+' : '') + dr.toFixed(0) + 'R';
                                    btn.innerHTML = `${predictionIndicator}<span class="day-pct ${rClass}">${rDisplay}</span>${tempIndicator}`;
                                } else {
                                    // All Trades mode: show win percentage
                                    const winPctClass = dayWinPct >= 60 ? 'green' : (dayWinPct >= 40 ? 'yellow' : 'red');
                                    btn.innerHTML = `${predictionIndicator}<span class="day-pct ${winPctClass}">${dayWinPct}%</span>${tempIndicator}`;
                                }
                            } else {
                                // No valid trades for this mode
                                if (calendarMode === 'best2' && allTrades.length > 0) {
                                    // Has trades but none in allowed zones - show as "no valid trades"
                                    // Calculate actual result for display
                                    const actualR = allTrades.reduce((s, t) => s + t.r, 0);
                                    const actualCount = allTrades.length;
                                    let actualEmoji = '';
                                    if (actualR >= actualCount) actualEmoji = 'üî•';
                                    else if (actualR >= actualCount * 0.5) actualEmoji = 'üå§Ô∏è';
                                    else actualEmoji = 'ü•∂';
                                    btn.innerHTML = `${predictionIndicator}<span class="sitout-label">‚ö†Ô∏è</span><span class="sitout-actual">${actualEmoji}</span>`;
                                    btn.className += ' sitout'; // Gray background
                                } else {
                                    // No trades yet
                                    btn.innerHTML = `${predictionIndicator}<span class="day-label">${dayName}</span>`;
                                }
                            }
                            btn.addEventListener('click', () => {
                                if (calendarMode === 'best2') {
                                    // Go straight to View Trades in Best 2 mode
                                    selectedDay = dayIndex;
                                    openViewModal();
                                } else {
                                    openMenuModal(dayIndex);
                                }
                            });
                        }
                        row.appendChild(btn);
                    }
                    grid.appendChild(row);
                }
                
                // Update toggle button states
                const allBtn = document.getElementById('calAllTrades' + pi);
                const best2Btn = document.getElementById('calBest2' + pi);
                if (allBtn) allBtn.className = 'calendar-toggle' + (calendarMode === 'all' ? ' active' : '');
                if (best2Btn) best2Btn.className = 'calendar-toggle' + (calendarMode === 'best2' ? ' active' : '');
            });
        }
        
        function setPage(p) {
            currentPage = p;
            document.getElementById('calendarSlider').style.transform = `translateX(-${p * 33.333}%)`;
            document.getElementById('dot0').className = 'dot' + (p === 0 ? ' active' : '');
            document.getElementById('dot1').className = 'dot' + (p === 1 ? ' active' : '');
            document.getElementById('dot2').className = 'dot' + (p === 2 ? ' active' : '');
            if (p === 2) renderGraph();
        }
        
        // Swipe
        let touchStartX = 0;
        document.getElementById('calendarWrap').addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; });
        document.getElementById('calendarWrap').addEventListener('touchend', e => {
            const dx = e.changedTouches[0].clientX - touchStartX;
            if (Math.abs(dx) > 50) {
                if (dx < 0 && currentPage < 2) setPage(currentPage + 1);
                else if (dx > 0 && currentPage > 0) setPage(currentPage - 1);
            }
        });
        
        document.getElementById('dot0').addEventListener('click', () => setPage(0));
        document.getElementById('dot1').addEventListener('click', () => setPage(1));
        document.getElementById('dot2').addEventListener('click', () => setPage(2));
        
        // Calendar toggles
        ['0', '1'].forEach(pi => {
            const allBtn = document.getElementById('calAllTrades' + pi);
            const best2Btn = document.getElementById('calBest2' + pi);
            if (allBtn) {
                allBtn.addEventListener('click', () => {
                    calendarMode = 'all';
                    calendarShowAll = true;
                    renderCalendar();
                    updateStats();
                });
            }
            if (best2Btn) {
                best2Btn.addEventListener('click', () => {
                    calendarMode = 'best2';
                    calendarShowAll = false;
                    renderZoneAnalysis();
                    renderCalendar();
                    updateStats();
                });
            }
        });
        
        // Week navigation
        const totalWeeks = Math.ceil(365 / 5);
        const weeksPerPage = 5;
        const maxOffset = Math.floor((totalWeeks - 1) / weeksPerPage);
        
        ['0', '1'].forEach(pi => {
            document.getElementById('weekPrev' + pi).addEventListener('click', () => {
                if (weekOffset > 0) {
                    weekOffset--;
                    renderCalendar();
                }
            });
            document.getElementById('weekNext' + pi).addEventListener('click', () => {
                if (weekOffset < maxOffset) {
                    weekOffset++;
                    renderCalendar();
                }
            });
        });
        
        // Collapse toggles for page 3
        document.getElementById('timesCollapseBtn').addEventListener('click', () => {
            const content = document.getElementById('timesCollapseContent');
            const arrow = document.getElementById('timesCollapseArrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        });
        
        document.getElementById('strategyCollapseBtn').addEventListener('click', () => {
            const content = document.getElementById('strategyCollapseContent');
            const arrow = document.getElementById('strategyCollapseArrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        });
        
        // Collapse toggles for bottom sections
        document.getElementById('statsCollapseBtn').addEventListener('click', () => {
            const content = document.getElementById('statsCollapseContent');
            const arrow = document.getElementById('statsCollapseArrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        });
        
        document.getElementById('progressCollapseBtn').addEventListener('click', () => {
            const content = document.getElementById('progressCollapseContent');
            const arrow = document.getElementById('progressCollapseArrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        });
        
        // Graph zoom controls
        document.getElementById('graphZoomIn').addEventListener('click', () => {
            if (graphZoom < 200) {
                graphZoom += 25;
                renderGraph(false);
            }
        });
        
        document.getElementById('graphZoomOut').addEventListener('click', () => {
            if (graphZoom > 50) {
                graphZoom -= 25;
                renderGraph(false);
            }
        });
        
        // Graph scroll arrows
        document.getElementById('graphScrollLeft').addEventListener('click', () => {
            const wrap = document.getElementById('graphScrollWrap');
            wrap.scrollBy({ left: -100, behavior: 'smooth' });
        });
        
        document.getElementById('graphScrollRight').addEventListener('click', () => {
            const wrap = document.getElementById('graphScrollWrap');
            wrap.scrollBy({ left: 100, behavior: 'smooth' });
        });
        
        // Graph bar click detection
        document.getElementById('graphCanvas').addEventListener('click', (e) => {
            const canvas = document.getElementById('graphCanvas');
            const rect = canvas.getBoundingClientRect();
            const scrollWrap = document.getElementById('graphScrollWrap');
            const x = (e.clientX - rect.left) * (canvas.width / rect.width / 2);
            const y = e.clientY - rect.top;
            
            // Find which bar was clicked
            for (const slot of graphSlots) {
                if (x >= slot.x && x <= slot.x + slot.barWidth) {
                    openGraphTradesModal(slot);
                    return;
                }
            }
        });
        
        // Modals
        function hideAllModals() {
            ['menuModal', 'viewModal', 'addModal', 'editModal', 'weekModal', 'clearModal', 'balanceModal', 'reviewModal', 'goalModal', 'timeRankModal'].forEach(id => document.getElementById(id).classList.add('hidden'));
        }
        
        function openMenuModal(dayIndex) {
            selectedDay = dayIndex;
            
            // Get day name based on position in week (dayIndex % 5 gives 0-4 for Mon-Fri)
            const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
            const nextDayNames = ['Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Monday'];
            const dayOfWeek = dayIndex % 5;
            const thisDayName = dayNames[dayOfWeek];
            const nextDayName = nextDayNames[dayOfWeek];
            
            document.getElementById('menuTitle').textContent = 'Day ' + (dayIndex + 1) + ' (' + thisDayName + ')';
            
            // Get prediction for NEXT day based on THIS day
            const predEl = document.getElementById('menuPrediction');
            const prediction = predictNextDay(dayIndex);
            
            if (!prediction) {
                predEl.className = 'menu-prediction neutral';
                predEl.innerHTML = `<div class="menu-prediction-header"><span class="menu-prediction-emoji">üìä</span><span class="menu-prediction-label" style="color:#888">NO TRADES</span></div><div class="menu-prediction-detail">Add trades to see ${nextDayName} prediction</div>`;
            } else {
                let predClass, emoji, label, labelClass, detail;
                
                // Get actual result for this day
                const actualEmoji = prediction.prevActual === 'hot' ? 'üî•' : (prediction.prevActual === 'warm' ? 'üå§Ô∏è' : 'ü•∂');
                
                if (prediction.prediction === 'hot') {
                    predClass = 'aggressive';
                    emoji = 'üü¢';
                    label = 'AGGRESSIVE';
                    labelClass = 'green';
                    detail = `${thisDayName} was ${actualEmoji} (${prediction.prevWinRate}%) ‚Äî Trade any best time on ${nextDayName}`;
                } else if (prediction.prediction === 'warm') {
                    predClass = 'cautious';
                    emoji = 'üü°';
                    label = 'CAUTIOUS';
                    labelClass = 'yellow';
                    detail = `${thisDayName} was ${actualEmoji} (${prediction.prevWinRate}%) ‚Äî Only trade top 3 times on ${nextDayName}`;
                } else {
                    predClass = 'defensive';
                    emoji = 'üî¥';
                    label = 'DEFENSIVE';
                    labelClass = 'red';
                    detail = `${thisDayName} was ${actualEmoji} (${prediction.prevWinRate}%) ‚Äî Only trade #1 time on ${nextDayName}, or sit out`;
                }
                
                // Get this day's R totals for display
                const dayTrades = days[dayIndex].trades;
                let greenR = 0, redR = 0;
                dayTrades.forEach(t => {
                    if (t.r > 0) greenR += t.r;
                    else if (t.r < 0) redR += Math.abs(t.r);
                });
                
                predEl.className = 'menu-prediction ' + predClass;
                predEl.innerHTML = `<div class="menu-prediction-header"><span class="menu-prediction-emoji">${emoji}</span><span class="menu-prediction-label ${labelClass}">${label}</span></div><div class="menu-prediction-detail">${detail}</div><div class="menu-prediction-ratio"><span class="green">+${greenR.toFixed(0)}R</span> / <span class="red">-${redR.toFixed(0)}R</span></div>`;
            }
            
            // Show top 3 best times with ‚úì/‚úó for trades - for BOTH All Trades and Best 2 tabs
            {
                // Use CURRENT best times (same for all days)
                const zones = window.sortedZones || [];
                
                const dayTrades = days[dayIndex].trades;
                
                // Helper to parse time
                const parseTimeToMinutes = (timeStr) => {
                    const parts = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                    if (!parts) return 0;
                    let h = parseInt(parts[1]);
                    const m = parseInt(parts[2]);
                    const ampm = parts[3].toUpperCase();
                    if (ampm === 'PM' && h !== 12) h += 12;
                    if (ampm === 'AM' && h === 12) h = 0;
                    return h * 60 + m;
                };
                
                // Show top 3 best times with ‚úì/‚úó showing which trades landed in each
                let zonesHtml = '<div class="menu-best-times"><div class="menu-best-times-header">üéØ Top 3 Best Times:</div>';
                if (zones.length === 0) {
                    zonesHtml += '<div class="menu-best-times-note">No trade data yet</div>';
                } else {
                    // Sort all trades by time to get order numbers
                    const top3 = zones.slice(0, 3);
                    top3.forEach((zone, i) => {
                        const zoneStart = parseTimeToMinutes(zone.start);
                        const zoneEnd = parseTimeToMinutes(zone.end);
                        
                        // Find trades that landed in this zone and sort by time
                        const tradesInZone = dayTrades.filter(t => {
                            const tradeMin = parseTimeToMinutes(t.time);
                            return tradeMin >= zoneStart && tradeMin <= zoneEnd;
                        }).sort((a, b) => parseTimeToMinutes(a.time) - parseTimeToMinutes(b.time));
                        
                        if (tradesInZone.length > 0) {
                            // Has trade(s) - compact format: AAPL +2R, TSLA -1R
                            const tradeList = tradesInZone.map(t => {
                                const rClass = t.r >= 0 ? 'green' : 'red';
                                return `<span class="${rClass}">${t.ticker} ${t.r >= 0 ? '+' : ''}${t.r}R</span>`;
                            }).join(' ¬∑ ');
                            zonesHtml += `<div class="zone-row hit">
                                <span class="zone-check">‚úì</span>
                                <span class="zone-rank">#${i + 1}</span>
                                <span class="zone-time">${zone.start}-${zone.end}</span>
                                <span class="zone-trades">${tradeList}</span>
                            </div>`;
                        } else {
                            // No trade in this zone
                            zonesHtml += `<div class="zone-row miss">
                                <span class="zone-check">‚úó</span>
                                <span class="zone-rank">#${i + 1}</span>
                                <span class="zone-time">${zone.start}-${zone.end}</span>
                                <span class="zone-trades dim">‚Äî</span>
                            </div>`;
                        }
                    });
                }
                zonesHtml += '</div>';
                predEl.innerHTML += zonesHtml;
            }
            
            hideAllModals();
            document.getElementById('menuModal').classList.remove('hidden');
        }
        
        function openViewModal() {
            document.getElementById('viewTitle').textContent = 'Day ' + (selectedDay + 1) + ' Trades';
            document.getElementById('viewBack').style.display = calendarMode === 'best2' ? 'none' : 'block';
            document.getElementById('viewAddBtn').style.display = 'block';
            const list = document.getElementById('tradesList');
            list.innerHTML = '';
            
            // Always show ALL trades, but highlight best 2
            let trades = days[selectedDay].trades;
            let best2TradeIds = [];
            
            // Get the best 2 trade IDs for highlighting
            const best2 = getBest2TradesForDay(selectedDay);
            best2TradeIds = best2.map(t => t.id);
            
            if (calendarMode === 'best2') {
                document.getElementById('viewTitle').textContent = 'Day ' + (selectedDay + 1) + ' Trades';
                
                // Use CURRENT best times (same for all days)
                const zones = window.sortedZones || [];
                
                // Get prediction for this day
                const prediction = selectedDay > 0 ? predictNextDay(selectedDay - 1) : null;
                const predType = prediction ? prediction.prediction : 'hot';
                
                let predLabel = '';
                let timesToShow = [];
                let timesTitle = '';
                
                if (predType === 'hot') {
                    predLabel = '<span class="pred-badge hot">üü¢ HOT - Trade any time</span>';
                    timesToShow = zones.slice(0, 5); // Show top 5 on hot days
                    timesTitle = 'üéØ Top 5 Best Times';
                } else if (predType === 'warm') {
                    predLabel = '<span class="pred-badge warm">üü° WARM - 70%+ win rate times only</span>';
                    timesToShow = zones.filter(z => z.winRate >= 70); // Show ALL 70%+ times
                    timesTitle = 'üéØ Allowed Times (70%+)';
                } else {
                    predLabel = '<span class="pred-badge cold">üî¥ SITOUT - No trading</span>';
                    timesToShow = [];
                    timesTitle = '‚õî No trading allowed';
                }
                
                let bestHtml = `<div class="view-best-times">
                    <div class="view-best-header">${predLabel}</div>
                    <div class="view-best-title">${timesTitle}</div>
                    <div class="view-best-list">`;
                
                if (predType === 'cold') {
                    bestHtml += '<div class="view-best-item" style="color:#ef4444;">This is a SITOUT day</div>';
                } else if (timesToShow.length === 0) {
                    bestHtml += '<div class="view-best-item">No data yet</div>';
                } else {
                    timesToShow.forEach((zone, i) => {
                        const is70Plus = zone.winRate >= 70;
                        const highlightClass = is70Plus ? ' highlighted' : '';
                        bestHtml += `<div class="view-best-item${highlightClass}">
                            <span class="view-best-rank">#${i + 1}</span>
                            <span class="view-best-time">${zone.start} - ${zone.end}</span>
                            <span class="view-best-rate ${is70Plus ? 'green' : ''}">${Math.round(zone.winRate)}%</span>
                        </div>`;
                    });
                }
                bestHtml += '</div></div>';
                list.innerHTML = bestHtml;
            }
            
            if (trades.length === 0) {
                list.innerHTML += '<div class="empty-state"><div class="empty-icon">üì≠</div>No trades yet</div>';
            } else {
                // Get zones for rank calculation
                const zones = window.sortedZones || [];
                
                // Helper to get zone info for a trade (rank and win rate)
                const getTradeZoneInfo = (trade) => {
                    if (zones.length === 0) return { rank: null, winRate: null };
                    
                    const parseTimeToMinutes = (timeStr) => {
                        const parts = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
                        if (!parts) return 0;
                        let h = parseInt(parts[1]);
                        const m = parseInt(parts[2]);
                        const ampm = parts[3].toUpperCase();
                        if (ampm === 'PM' && h !== 12) h += 12;
                        if (ampm === 'AM' && h === 12) h = 0;
                        return h * 60 + m;
                    };
                    
                    const tradeMin = parseTimeToMinutes(trade.time);
                    let bestRank = 9999;
                    let bestWinRate = null;
                    
                    for (let i = 0; i < zones.length; i++) {
                        const zone = zones[i];
                        const zoneStart = parseTimeToMinutes(zone.start);
                        const zoneEnd = parseTimeToMinutes(zone.end);
                        
                        if (tradeMin >= zoneStart && tradeMin <= zoneEnd) {
                            if (i + 1 < bestRank) {
                                bestRank = i + 1;
                                bestWinRate = zone.winRate;
                            }
                        }
                    }
                    
                    return {
                        rank: bestRank <= zones.length ? bestRank : null,
                        winRate: bestWinRate
                    };
                };
                
                trades.forEach((t, idx) => {
                    const div = document.createElement('div');
                    const isBest2 = best2TradeIds.includes(t.id);
                    div.className = 'trade-item' + (t.taken ? '' : ' setup') + (isBest2 ? ' best2-highlight' : '');
                    const indicators = [];
                    if (t.notes) indicators.push('üìù');
                    if (t.photo) indicators.push('üì∑');
                    const timeDisplay = t.entryTime || t.time;
                    const candlesDisplay = t.candles ? ` ¬∑ ${t.candles} üïØÔ∏è` : '';
                    const durationDisplay = t.duration ? ` (${t.duration >= 60 ? Math.floor(t.duration/60) + 'm ' + (t.duration % 60 > 0 ? (t.duration % 60) + 's' : '') : t.duration + 's'})` : '';
                    const tradeNum = `<span class="trade-num">#${idx + 1}</span>`;
                    const best2Badge = isBest2 ? '<span class="best2-badge">‚≠ê</span>' : '';
                    
                    // Get zone info for this trade
                    const zoneInfo = getTradeZoneInfo(t);
                    const winRateClass = zoneInfo.winRate >= 70 ? 'high' : (zoneInfo.winRate >= 50 ? 'mid' : 'low');
                    const winRateDisplay = zoneInfo.winRate !== null 
                        ? `<span class="trade-winrate ${winRateClass}">${Math.round(zoneInfo.winRate)}%</span>` 
                        : '<span class="trade-winrate none">--%</span>';
                    
                    div.innerHTML = tradeNum + '<div class="trade-info"><div class="trade-ticker">' + best2Badge + t.ticker + (t.taken ? '' : '<span style="font-size:9px;color:#555;margin-left:4px">(setup)</span>') + (indicators.length ? '<span style="font-size:10px;margin-left:6px">' + indicators.join(' ') + '</span>' : '') + '</div><div class="trade-time">' + timeDisplay + '<span style="color:#888">' + candlesDisplay + '</span><span style="color:#22c55e">' + durationDisplay + '</span></div></div>' + winRateDisplay + '<span class="trade-r ' + (t.r >= 0 ? 'green' : 'red') + '">' + (t.r > 0 ? '+' : '') + t.r + 'R</span><button class="trade-btn edit-btn" data-id="' + t.id + '">‚úé</button><button class="trade-btn delete-btn" data-id="' + t.id + '">üóë</button>';
                    list.appendChild(div);
                });
                list.querySelectorAll('.edit-btn').forEach(btn => btn.addEventListener('click', () => openEditModal(parseInt(btn.dataset.id))));
                list.querySelectorAll('.delete-btn').forEach(btn => btn.addEventListener('click', () => deleteTrade(parseInt(btn.dataset.id))));
            }
            hideAllModals();
            document.getElementById('viewModal').classList.remove('hidden');
        }
        
        function openAddModal() {
            document.getElementById('tickerInput').value = '';
            document.getElementById('entryTimeSelect').value = '9:30 AM';
            document.getElementById('candlesInput').value = '';
            document.getElementById('durationInput').value = '';
            document.getElementById('durationDisplay').textContent = '';
            document.getElementById('rSelect').value = '2';
            document.querySelectorAll('#rBtns .r-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.r === '2');
            });
            document.getElementById('notesInput').value = '';
            newTradeTaken = true;
            newTradePhoto = null;
            newTradeTags = [];
            document.getElementById('typeTaken').className = 'type-btn active';
            document.getElementById('typeSetup').className = 'type-btn';
            document.querySelectorAll('#tagsWrap .tag-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('photoPreview').innerHTML = '';
            document.getElementById('photoPreview').className = 'photo-preview';
            hideAllModals();
            document.getElementById('addModal').classList.remove('hidden');
        }
        
        function openEditModal(tradeId) {
            const trade = days[selectedDay].trades.find(t => t.id === tradeId);
            if (!trade) return;
            editingTrade = trade;
            document.getElementById('editTickerInput').value = trade.ticker;
            document.getElementById('editEntryTimeSelect').value = trade.entryTime || trade.time || '9:30 AM';
            document.getElementById('editCandlesInput').value = trade.candles || '';
            document.getElementById('editRSelect').value = trade.r.toString();
            document.getElementById('editDurationInput').value = trade.duration || '';
            if (trade.duration) {
                const secs = trade.duration;
                if (secs >= 60) {
                    const mins = Math.floor(secs / 60);
                    const s = secs % 60;
                    document.getElementById('editDurationDisplay').textContent = s > 0 ? `(${mins}m ${s}s)` : `(${mins}m)`;
                } else {
                    document.getElementById('editDurationDisplay').textContent = `(${secs}s)`;
                }
            } else {
                document.getElementById('editDurationDisplay').textContent = '';
            }
            document.getElementById('editNotesInput').value = trade.notes || '';
            editTradeTaken = trade.taken;
            editTradePhoto = trade.photo || null;
            editTradeTags = trade.tags ? [...trade.tags] : [];
            document.getElementById('editTypeTaken').className = 'type-btn' + (trade.taken ? ' active' : '');
            document.getElementById('editTypeSetup').className = 'type-btn' + (trade.taken ? '' : ' active');
            // Set R buttons
            document.getElementById('editRSelect').value = trade.r.toString();
            document.querySelectorAll('#editRBtns .r-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.r === trade.r.toString());
            });
            // Set tag buttons
            document.querySelectorAll('#editTagsWrap .tag-btn').forEach(btn => {
                btn.classList.toggle('active', editTradeTags.includes(btn.dataset.tag));
            });
            const preview = document.getElementById('editPhotoPreview');
            if (editTradePhoto) {
                preview.innerHTML = '<img src="' + editTradePhoto + '"><button class="photo-remove" id="editRemovePhoto">√ó</button>';
                preview.className = 'photo-preview has-photo';
            } else {
                preview.innerHTML = '';
                preview.className = 'photo-preview';
            }
            hideAllModals();
            document.getElementById('editModal').classList.remove('hidden');
            if (editTradePhoto) {
                document.getElementById('editRemovePhoto').addEventListener('click', (e) => {
                    e.stopPropagation();
                    editTradePhoto = null;
                    preview.innerHTML = '';
                    preview.className = 'photo-preview';
                });
            }
        }
        
        function openWeekModal(wi) {
            selectedWeek = wi;
            const w = calcWeek(wi);
            
            // Calculate Best 2 stats
            let best2Stats = { r: 0, trades: 0, wins: 0, losses: 0 };
            for (let d = 0; d < 5; d++) {
                const dayIdx = wi * 5 + d;
                if (dayIdx < days.length) {
                    const best2Trades = getBest2TradesForDay(dayIdx);
                    best2Trades.forEach(t => {
                        best2Stats.r += t.r;
                        best2Stats.trades++;
                        if (t.r > 0) best2Stats.wins++;
                        else if (t.r < 0) best2Stats.losses++;
                    });
                }
            }
            
            // Use CURRENT best times (same for all weeks)
            const zones = window.sortedZones || [];
            
            // Populate best times list
            const bestTimesEl = document.getElementById('weekBestTimes');
            if (zones.length === 0) {
                bestTimesEl.innerHTML = '<div class="week-no-data">No trades yet</div>';
            } else {
                const top3 = zones.slice(0, 3);
                bestTimesEl.innerHTML = top3.map((zone, i) => `
                    <div class="week-best-time-item">
                        <div class="week-best-time-rank">#${i + 1}</div>
                        <div class="week-best-time-time">${zone.start} - ${zone.end}</div>
                        <div class="week-best-time-stats">${zone.winRate.toFixed(1)}% win ¬∑ ${zone.trades} trades ¬∑ ${zone.netR >= 0 ? '+' : ''}${zone.netR.toFixed(1)}R</div>
                    </div>
                `).join('');
            }
            
            document.getElementById('weekTitle').textContent = 'Week ' + (wi + 1);
            
            if (calendarMode === 'best2') {
                // Show Best 2 stats only
                const myREl = document.getElementById('weekMyR');
                myREl.className = 'week-stat full ' + (best2Stats.r >= 0 ? 'positive' : 'negative');
                myREl.innerHTML = `<div class="week-stat-value big ${best2Stats.r >= 0 ? 'green' : 'red'}">${best2Stats.r > 0 ? '+' : ''}${best2Stats.r.toFixed(1)}R</div><div style="font-size:10px;color:#888;margin-top:4px;">Best 2 Trades</div>`;
                document.getElementById('weekMyTrades').textContent = best2Stats.trades;
                document.getElementById('weekMyWinRate').textContent = best2Stats.trades ? Math.round(best2Stats.wins / best2Stats.trades * 100) + '%' : '0%';
                document.getElementById('weekMyWins').textContent = best2Stats.wins;
                document.getElementById('weekMyLosses').textContent = best2Stats.losses;
                
                // Show comparison to actual
                const allREl = document.getElementById('weekAllR');
                allREl.className = 'week-stat full ' + (w.myR >= 0 ? 'positive' : 'negative');
                allREl.innerHTML = `<div class="week-stat-value big ${w.myR >= 0 ? 'green' : 'red'}">${w.myR > 0 ? '+' : ''}${w.myR.toFixed(1)}R</div><div style="font-size:10px;color:#888;margin-top:4px;">Your Actual</div>`;
                document.getElementById('weekAllTrades').textContent = w.my;
                document.getElementById('weekAllWinRate').textContent = w.my ? Math.round(w.myW / w.my * 100) + '%' : '0%';
                document.getElementById('weekAllWins').textContent = w.myW;
                document.getElementById('weekAllLosses').textContent = w.myL;
            } else {
                const myREl = document.getElementById('weekMyR');
                myREl.className = 'week-stat full ' + (w.myR >= 0 ? 'positive' : 'negative');
                myREl.innerHTML = `<div class="week-stat-value big ${w.myR >= 0 ? 'green' : 'red'}">${w.myR > 0 ? '+' : ''}${w.myR.toFixed(1)}R</div>`;
                document.getElementById('weekMyTrades').textContent = w.my;
                document.getElementById('weekMyWinRate').textContent = w.my ? Math.round(w.myW / w.my * 100) + '%' : '0%';
                document.getElementById('weekMyWins').textContent = w.myW;
                document.getElementById('weekMyLosses').textContent = w.myL;
                const allREl = document.getElementById('weekAllR');
                allREl.className = 'week-stat full ' + (w.allR >= 0 ? 'positive' : 'negative');
                allREl.innerHTML = `<div class="week-stat-value big ${w.allR >= 0 ? 'green' : 'red'}">${w.allR > 0 ? '+' : ''}${w.allR.toFixed(1)}R</div>`;
                document.getElementById('weekAllTrades').textContent = w.all;
                document.getElementById('weekAllWinRate').textContent = w.all ? Math.round(w.allW / w.all * 100) + '%' : '0%';
                document.getElementById('weekAllWins').textContent = w.allW;
                document.getElementById('weekAllLosses').textContent = w.allL;
            }
            hideAllModals();
            document.getElementById('weekModal').classList.remove('hidden');
        }
        
        // Actions
        function addTrade() {
            const ticker = document.getElementById('tickerInput').value.trim().toUpperCase();
            if (!ticker) return;
            
            // Auto-detect day of week from current date
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const today = new Date();
            const dayOfWeek = dayNames[today.getDay()];
            
            // Set the day's dayOfWeek if not already set
            if (!days[selectedDay].dayOfWeek && ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'].includes(dayOfWeek)) {
                days[selectedDay].dayOfWeek = dayOfWeek;
            }
            
            const entryTime = document.getElementById('entryTimeSelect').value;
            const candles = parseInt(document.getElementById('candlesInput').value) || null;
            
            days[selectedDay].trades.push({
                id: Date.now(),
                ticker,
                time: entryTime,
                entryTime: entryTime,
                candles: candles,
                r: parseFloat(document.getElementById('rSelect').value),
                duration: parseInt(document.getElementById('durationInput').value) || null,
                taken: newTradeTaken,
                notes: document.getElementById('notesInput').value.trim(),
                photo: newTradePhoto,
                tags: [...newTradeTags]
            });
            
            // Sort trades by entry time
            sortTradesByTime(selectedDay);
            
            saveData();
            updateStats();
            renderCalendar();
            newTradePhoto = null;
            newTradeTags = [];
            document.getElementById('candlesInput').value = '';
            document.getElementById('durationInput').value = '';
            document.getElementById('durationDisplay').textContent = '';
            document.querySelectorAll('#tagsWrap .tag-btn').forEach(btn => btn.classList.remove('active'));
            openViewModal();
        }
        
        // Sort trades by entry time
        function sortTradesByTime(dayIndex) {
            days[dayIndex].trades.sort((a, b) => {
                const timeA = parseTimeToMinutes(a.entryTime || a.time);
                const timeB = parseTimeToMinutes(b.entryTime || b.time);
                return timeA - timeB;
            });
        }
        
        function saveEditTrade() {
            if (!editingTrade) return;
            const trade = days[selectedDay].trades.find(t => t.id === editingTrade.id);
            if (trade) {
                const entryTime = document.getElementById('editEntryTimeSelect').value;
                const candles = parseInt(document.getElementById('editCandlesInput').value) || null;
                trade.ticker = document.getElementById('editTickerInput').value.trim().toUpperCase();
                trade.time = entryTime;
                trade.entryTime = entryTime;
                trade.candles = candles;
                trade.r = parseFloat(document.getElementById('editRSelect').value);
                trade.duration = parseInt(document.getElementById('editDurationInput').value) || null;
                trade.taken = editTradeTaken;
                trade.notes = document.getElementById('editNotesInput').value.trim();
                trade.photo = editTradePhoto;
                trade.tags = [...editTradeTags];
            }
            
            // Sort trades by entry time
            sortTradesByTime(selectedDay);
            
            saveData();
            updateStats();
            renderCalendar();
            editTradePhoto = null;
            openViewModal();
        }
        
        function deleteTrade(tradeId) {
            days[selectedDay].trades = days[selectedDay].trades.filter(t => t.id !== tradeId);
            saveData();
            updateStats();
            renderCalendar();
            openViewModal();
        }
        
        function clearPageData(pageNum) {
            for (let i = pageNum * 25; i < pageNum * 25 + 25; i++) days[i] = { id: i, trades: [] };
            saveData();
            updateStats();
            renderCalendar();
            hideAllModals();
        }
        
        // Event listeners
        document.getElementById('menuClose').addEventListener('click', hideAllModals);
        document.getElementById('viewClose').addEventListener('click', hideAllModals);
        document.getElementById('addClose').addEventListener('click', hideAllModals);
        document.getElementById('editClose').addEventListener('click', hideAllModals);
        document.getElementById('weekClose').addEventListener('click', hideAllModals);
        document.getElementById('clearClose').addEventListener('click', hideAllModals);
        document.getElementById('balanceClose').addEventListener('click', hideAllModals);
        
        document.getElementById('addTradeBtn').addEventListener('click', openAddModal);
        document.getElementById('viewTradesBtn').addEventListener('click', openViewModal);
        document.getElementById('viewAddBtn').addEventListener('click', openAddModal);
        document.getElementById('duplicateBtn').addEventListener('click', () => {
            // Find last trade across all days
            let lastTrade = null;
            for (let i = days.length - 1; i >= 0; i--) {
                if (days[i].trades.length > 0) {
                    lastTrade = days[i].trades[days[i].trades.length - 1];
                    break;
                }
            }
            if (lastTrade) {
                // Open add modal with prefilled data
                document.getElementById('tickerInput').value = lastTrade.ticker;
                document.getElementById('entryTimeSelect').value = lastTrade.entryTime || lastTrade.time || '9:30 AM';
                document.getElementById('candlesInput').value = lastTrade.candles || '';
                document.getElementById('durationInput').value = lastTrade.duration || '';
                if (lastTrade.duration) {
                    const secs = lastTrade.duration;
                    if (secs >= 60) {
                        const mins = Math.floor(secs / 60);
                        const s = secs % 60;
                        document.getElementById('durationDisplay').textContent = s > 0 ? `(${mins}m ${s}s)` : `(${mins}m)`;
                    } else {
                        document.getElementById('durationDisplay').textContent = `(${secs}s)`;
                    }
                } else {
                    document.getElementById('durationDisplay').textContent = '';
                }
                document.getElementById('rSelect').value = '2';
                document.querySelectorAll('#rBtns .r-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.r === '2');
                });
                newTradeTaken = lastTrade.taken;
                document.getElementById('typeTaken').className = 'type-btn' + (lastTrade.taken ? ' active' : '');
                document.getElementById('typeSetup').className = 'type-btn' + (lastTrade.taken ? '' : ' active');
                newTradeTags = [];
                document.querySelectorAll('#tagsWrap .tag-btn').forEach(btn => btn.classList.remove('active'));
                newTradePhoto = null;
                document.getElementById('photoPreview').innerHTML = '';
                document.getElementById('photoPreview').className = 'photo-preview';
                document.getElementById('notesInput').value = '';
                hideAllModals();
                document.getElementById('addModal').classList.remove('hidden');
            } else {
                openAddModal();
            }
        });
        document.getElementById('viewBack').addEventListener('click', () => openMenuModal(selectedDay));
        document.getElementById('addBack').addEventListener('click', openViewModal);
        document.getElementById('editBack').addEventListener('click', openViewModal);
        
        document.getElementById('typeTaken').addEventListener('click', () => { newTradeTaken = true; document.getElementById('typeTaken').className = 'type-btn active'; document.getElementById('typeSetup').className = 'type-btn'; });
        document.getElementById('typeSetup').addEventListener('click', () => { newTradeTaken = false; document.getElementById('typeTaken').className = 'type-btn'; document.getElementById('typeSetup').className = 'type-btn active'; });
        document.getElementById('editTypeTaken').addEventListener('click', () => { editTradeTaken = true; document.getElementById('editTypeTaken').className = 'type-btn active'; document.getElementById('editTypeSetup').className = 'type-btn'; });
        document.getElementById('editTypeSetup').addEventListener('click', () => { editTradeTaken = false; document.getElementById('editTypeTaken').className = 'type-btn'; document.getElementById('editTypeSetup').className = 'type-btn active'; });
        
        // R button handling for Add Trade
        document.querySelectorAll('#rBtns .r-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('#rBtns .r-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('rSelect').value = btn.dataset.r;
            });
        });
        
        // R button handling for Edit Trade
        document.querySelectorAll('#editRBtns .r-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('#editRBtns .r-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('editRSelect').value = btn.dataset.r;
            });
        });
        
        // Tag handling for Add Trade
        document.querySelectorAll('#tagsWrap .tag-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const tag = btn.dataset.tag;
                if (newTradeTags.includes(tag)) {
                    newTradeTags = newTradeTags.filter(t => t !== tag);
                    btn.classList.remove('active');
                } else {
                    newTradeTags.push(tag);
                    btn.classList.add('active');
                }
            });
        });
        
        // Tag handling for Edit Trade
        document.querySelectorAll('#editTagsWrap .tag-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const tag = btn.dataset.tag;
                if (editTradeTags.includes(tag)) {
                    editTradeTags = editTradeTags.filter(t => t !== tag);
                    btn.classList.remove('active');
                } else {
                    editTradeTags.push(tag);
                    btn.classList.add('active');
                }
            });
        });
        
        // Goal handlers
        document.getElementById('dailyGoalBtn').addEventListener('click', () => {
            currentGoalType = 'daily';
            document.getElementById('goalModalTitle').textContent = 'Set Daily Goal';
            document.getElementById('goalInput').value = dailyGoal;
            hideAllModals();
            document.getElementById('goalModal').classList.remove('hidden');
        });
        document.getElementById('weeklyGoalBtn').addEventListener('click', () => {
            currentGoalType = 'weekly';
            document.getElementById('goalModalTitle').textContent = 'Set Weekly Goal';
            document.getElementById('goalInput').value = weeklyGoal;
            hideAllModals();
            document.getElementById('goalModal').classList.remove('hidden');
        });
        document.getElementById('goalClose').addEventListener('click', hideAllModals);
        document.querySelectorAll('.goal-preset').forEach(btn => {
            btn.addEventListener('click', () => {
                document.getElementById('goalInput').value = btn.dataset.amount;
            });
        });
        document.getElementById('saveGoal').addEventListener('click', () => {
            const val = parseFloat(document.getElementById('goalInput').value);
            if (!isNaN(val) && val > 0) {
                if (currentGoalType === 'daily') {
                    dailyGoal = val;
                    saveToDB('dailyGoal', dailyGoal);
                } else {
                    weeklyGoal = val;
                    saveToDB('weeklyGoal', weeklyGoal);
                }
                updateStats();
                hideAllModals();
            }
        });
        
        // Weekly review
        document.getElementById('weeklyReviewBtn').addEventListener('click', () => {
            generateWeeklyReview();
            hideAllModals();
            document.getElementById('reviewModal').classList.remove('hidden');
        });
        document.getElementById('reviewClose').addEventListener('click', hideAllModals);
        
        // Review toggle listeners
        document.getElementById('reviewMyTrades').addEventListener('click', () => {
            reviewShowAll = false;
            generateWeeklyReview();
        });
        document.getElementById('reviewAllTrades').addEventListener('click', () => {
            reviewShowAll = true;
            generateWeeklyReview();
        });
        
        let reviewShowAll = false; // false = my trades, true = all trades
        
        function generateWeeklyReview() {
            const s = calcStats();
            const showAll = reviewShowAll;
            
            // Update toggle button states
            document.getElementById('reviewMyTrades').className = 'calendar-toggle' + (showAll ? '' : ' active');
            document.getElementById('reviewAllTrades').className = 'calendar-toggle' + (showAll ? ' active' : '');
            
            const daysWithTrades = days.filter(d => showAll ? d.trades.length > 0 : d.trades.some(t => t.taken)).length;
            const currentWeekIndex = Math.floor((daysWithTrades > 0 ? daysWithTrades - 1 : 0) / 5);
            const weekData = calcWeek(currentWeekIndex);
            
            // Use appropriate stats based on toggle
            const count = showAll ? s.allCount : s.myCount;
            const wins = showAll ? s.allWins : s.myWins;
            const losses = showAll ? s.allLosses : s.myLosses;
            const totalR = showAll ? s.allR : s.myR;
            const weekR = showAll ? weekData.allR : weekData.myR;
            const weekCount = showAll ? weekData.all : weekData.my;
            
            // Count tags across trades based on toggle
            const tagCounts = {};
            days.forEach(d => d.trades.forEach(t => {
                if (showAll || t.taken) {
                    if (t.tags) t.tags.forEach(tag => { tagCounts[tag] = (tagCounts[tag] || 0) + 1; });
                }
            }));
            
            // Best and worst days based on toggle
            let bestDay = { index: -1, r: -Infinity };
            let worstDay = { index: -1, r: Infinity };
            days.forEach((d, i) => {
                const relevantTrades = showAll ? d.trades : d.trades.filter(t => t.taken);
                const dr = relevantTrades.reduce((sum, t) => sum + t.r, 0);
                if (relevantTrades.length > 0) {
                    if (dr > bestDay.r) bestDay = { index: i, r: dr };
                    if (dr < worstDay.r) worstDay = { index: i, r: dr };
                }
            });
            
            const winRate = count > 0 ? ((wins / count) * 100).toFixed(0) : 0;
            const tradeLabel = showAll ? 'All Setups' : 'Trades Taken';
            
            let html = '<div class="review-section"><div class="review-title">üìà Week ' + (currentWeekIndex + 1) + ' Summary</div>';
            html += '<div class="review-stat"><span class="review-stat-label">' + tradeLabel + '</span><span class="review-stat-value">' + weekCount + '</span></div>';
            html += '<div class="review-stat"><span class="review-stat-label">Win Rate</span><span class="review-stat-value">' + winRate + '%</span></div>';
            html += '<div class="review-stat"><span class="review-stat-label">Total R</span><span class="review-stat-value ' + (weekR >= 0 ? 'green' : 'red') + '">' + (weekR >= 0 ? '+' : '') + weekR.toFixed(1) + 'R</span></div>';
            html += '<div class="review-stat"><span class="review-stat-label">Weekly Goal</span><span class="review-stat-value">' + (weekR >= weeklyGoal ? '‚úÖ Achieved!' : '‚ùå ' + (weeklyGoal - weekR).toFixed(1) + 'R to go') + '</span></div>';
            html += '</div>';
            
            html += '<div class="review-section"><div class="review-title">üèÜ Challenge Progress</div>';
            html += '<div class="review-stat"><span class="review-stat-label">Days Completed</span><span class="review-stat-value">' + daysWithTrades + '/365</span></div>';
            html += '<div class="review-stat"><span class="review-stat-label">Overall R</span><span class="review-stat-value ' + (totalR >= 0 ? 'green' : 'red') + '">' + (totalR >= 0 ? '+' : '') + totalR.toFixed(1) + 'R</span></div>';
            if (bestDay.index >= 0) html += '<div class="review-stat"><span class="review-stat-label">Best Day</span><span class="review-stat-value green">D' + (bestDay.index + 1) + ' (+' + bestDay.r.toFixed(1) + 'R)</span></div>';
            if (worstDay.index >= 0 && worstDay.r < 0) html += '<div class="review-stat"><span class="review-stat-label">Worst Day</span><span class="review-stat-value red">D' + (worstDay.index + 1) + ' (' + worstDay.r.toFixed(1) + 'R)</span></div>';
            html += '</div>';
            
            if (Object.keys(tagCounts).length > 0) {
                html += '<div class="review-section"><div class="review-title">üè∑Ô∏è Trade Tags</div><div class="review-tags">';
                Object.entries(tagCounts).sort((a, b) => b[1] - a[1]).forEach(([tag, count]) => {
                    html += '<span class="review-tag">' + tag + '<span class="count">√ó' + count + '</span></span>';
                });
                html += '</div></div>';
            }
            
            document.getElementById('reviewContent').innerHTML = html;
        }
        
        document.getElementById('submitTrade').addEventListener('click', (e) => { e.stopPropagation(); addTrade(); });
        document.getElementById('saveEdit').addEventListener('click', (e) => { e.stopPropagation(); saveEditTrade(); });
        
        // Photo handling for Add Trade
        document.getElementById('takePhotoBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const input = document.getElementById('photoInput');
            input.setAttribute('capture', 'environment');
            input.click();
        });
        document.getElementById('choosePhotoBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const input = document.getElementById('photoInput');
            input.removeAttribute('capture');
            input.click();
        });
        document.getElementById('photoInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    newTradePhoto = ev.target.result;
                    const preview = document.getElementById('photoPreview');
                    preview.innerHTML = '<img src="' + newTradePhoto + '"><button class="photo-remove" id="removePhoto">√ó</button>';
                    preview.className = 'photo-preview has-photo';
                    document.getElementById('removePhoto').addEventListener('click', (e) => {
                        e.stopPropagation();
                        newTradePhoto = null;
                        preview.innerHTML = '';
                        preview.className = 'photo-preview';
                    });
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Photo handling for Edit Trade
        document.getElementById('editTakePhotoBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const input = document.getElementById('editPhotoInput');
            input.setAttribute('capture', 'environment');
            input.click();
        });
        document.getElementById('editChoosePhotoBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const input = document.getElementById('editPhotoInput');
            input.removeAttribute('capture');
            input.click();
        });
        document.getElementById('editPhotoInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    editTradePhoto = ev.target.result;
                    const preview = document.getElementById('editPhotoPreview');
                    preview.innerHTML = '<img src="' + editTradePhoto + '"><button class="photo-remove" id="editRemovePhoto">√ó</button>';
                    preview.className = 'photo-preview has-photo';
                    document.getElementById('editRemovePhoto').addEventListener('click', (e) => {
                        e.stopPropagation();
                        editTradePhoto = null;
                        preview.innerHTML = '';
                        preview.className = 'photo-preview';
                    });
                };
                reader.readAsDataURL(file);
            }
        });
        
        document.getElementById('refreshBtn').addEventListener('click', () => { hideAllModals(); document.getElementById('clearModal').classList.remove('hidden'); });
        document.getElementById('clearPage1').addEventListener('click', () => clearPageData(0));
        document.getElementById('clearPage2').addEventListener('click', () => clearPageData(1));
        document.getElementById('clearCancel').addEventListener('click', hideAllModals);
        
        document.getElementById('balanceBtn').addEventListener('click', () => {
            document.getElementById('currentBalance').textContent = '$' + startingBalance.toLocaleString();
            document.getElementById('balanceInput').value = '';
            hideAllModals();
            document.getElementById('balanceModal').classList.remove('hidden');
        });
        document.querySelectorAll('.balance-preset').forEach(btn => btn.addEventListener('click', () => { document.getElementById('balanceInput').value = btn.dataset.amount; }));
        document.getElementById('saveBalance').addEventListener('click', () => {
            const val = parseFloat(document.getElementById('balanceInput').value);
            if (!isNaN(val) && val > 0) { startingBalance = val; saveData(); updateStats(); hideAllModals(); }
        });
        
        // Click outside modal to close
        ['menuModal', 'viewModal', 'addModal', 'editModal', 'weekModal', 'clearModal', 'balanceModal', 'timeRankModal'].forEach(id => {
            document.getElementById(id).addEventListener('click', e => { if (e.target.classList.contains('modal-overlay')) hideAllModals(); });
        });
        
        // Time ranking button listeners
        document.getElementById('bestTimeBtn').addEventListener('click', () => showTimeRankModal('best'));
        document.getElementById('worstTimeBtn').addEventListener('click', () => showTimeRankModal('worst'));
        document.getElementById('twoTradeBtn').addEventListener('click', showTwoTradeModal);
        document.getElementById('top3Times0').addEventListener('click', showTwoTradeModal);
        document.getElementById('top3Times1').addEventListener('click', showTwoTradeModal);
        document.getElementById('timeRankClose').addEventListener('click', hideAllModals);
        document.getElementById('splashDismiss').addEventListener('click', () => {
            document.getElementById('splashModal').classList.add('hidden');
        });
        document.getElementById('splashModal').addEventListener('click', e => {
            if (e.target.classList.contains('modal-overlay')) {
                document.getElementById('splashModal').classList.add('hidden');
            }
        });
        
        // Show splash prediction on app open
        function showSplashPrediction() {
            // Find the most recent day with trades
            let lastDayWithTrades = -1;
            for (let i = days.length - 1; i >= 0; i--) {
                if (days[i].trades.length > 0) {
                    lastDayWithTrades = i;
                    break;
                }
            }
            
            if (lastDayWithTrades < 0) {
                // No trades yet, don't show splash
                return;
            }
            
            // Get prediction for next day
            const prediction = predictNextDay(lastDayWithTrades);
            if (!prediction) return;
            
            // Day names
            const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
            const lastDayOfWeek = lastDayWithTrades % 5;
            const lastDayName = dayNames[lastDayOfWeek];
            const nextDayName = dayNames[(lastDayOfWeek + 1) % 5];
            
            // Get actual emoji for last day
            const actualEmoji = prediction.prevActual === 'hot' ? 'üî•' : (prediction.prevActual === 'warm' ? 'üå§Ô∏è' : 'ü•∂');
            
            // Set header based on prediction
            const splashModal = document.querySelector('.splash-modal');
            const headerEl = document.getElementById('splashHeader');
            const subtextEl = document.getElementById('splashSubtext');
            const adviceEl = document.getElementById('splashAdvice');
            const timesEl = document.getElementById('splashTimes');
            
            // Remove old classes
            splashModal.className = 'splash-modal';
            headerEl.className = 'splash-header';
            
            if (prediction.prediction === 'hot') {
                splashModal.classList.add('aggressive');
                headerEl.classList.add('green');
                headerEl.textContent = 'üü¢ AGGRESSIVE';
                adviceEl.textContent = `Trade any best time on ${nextDayName}`;
            } else if (prediction.prediction === 'warm') {
                splashModal.classList.add('cautious');
                headerEl.classList.add('yellow');
                headerEl.textContent = 'üü° CAUTIOUS';
                adviceEl.textContent = `Only trade top 3 times on ${nextDayName}`;
            } else {
                splashModal.classList.add('defensive');
                headerEl.classList.add('red');
                headerEl.textContent = 'üî¥ DEFENSIVE';
                adviceEl.textContent = `Only trade #1 time on ${nextDayName}, or sit out`;
            }
            
            subtextEl.textContent = `${lastDayName} was ${actualEmoji} (${prediction.prevWinRate}%)`;
            
            // Show times based on prediction
            const zones = window.sortedZones || [];
            // Removed debug log
            
            if (zones.length > 0) {
                let timesToShow;
                let timesLabel;
                
                if (prediction.prediction === 'hot') {
                    timesToShow = zones.slice(0, 3); // Show top 3 for reference
                    timesLabel = 'Trade any of your best times:';
                } else if (prediction.prediction === 'warm') {
                    timesToShow = zones.slice(0, 3);
                    timesLabel = 'ONLY trade these top 3 times:';
                } else {
                    timesToShow = zones.slice(0, 1);
                    timesLabel = 'ONLY trade this #1 time:';
                }
                
                timesEl.innerHTML = `<div class="splash-times-label">${timesLabel}</div>` + 
                    timesToShow.map((zone, i) => `
                    <div class="splash-time-box">
                        <div class="splash-time-rank">#${i + 1}</div>
                        <div class="splash-time-value">${zone.start}</div>
                        <div class="splash-time-to">to ${zone.end}</div>
                        <div class="splash-time-pct">${Math.round(zone.winRate)}% win</div>
                    </div>
                `).join('');
            } else {
                timesEl.innerHTML = '<div style="color:#666;font-size:12px">Add more trades to see best times</div>';
            }
            
            // Show the splash
            document.getElementById('splashModal').classList.remove('hidden');
        }
        
        // Init - load from IndexedDB
        openDB().then(async () => {
            const savedDays = await loadFromDB('days');
            const savedBalance = await loadFromDB('balance');
            const savedDailyGoal = await loadFromDB('dailyGoal');
            const savedWeeklyGoal = await loadFromDB('weeklyGoal');
            if (savedDays && Array.isArray(savedDays)) {
                // Merge saved days with default array (handles old data with fewer days)
                for (let i = 0; i < savedDays.length && i < 365; i++) {
                    if (savedDays[i] && savedDays[i].trades) {
                        days[i] = savedDays[i];
                    }
                }
            }
            if (savedBalance) startingBalance = savedBalance;
            if (savedDailyGoal) dailyGoal = savedDailyGoal;
            if (savedWeeklyGoal) weeklyGoal = savedWeeklyGoal;
            // Calculate todayIndex - first day without taken trades, or last day with trades
            todayIndex = 0;
            for (let i = 0; i < days.length; i++) {
                if (days[i].trades.some(t => t.taken)) {
                    todayIndex = i;
                }
            }
            // If last day has trades, move to next day (unless at end)
            if (todayIndex < 49 && days[todayIndex].trades.some(t => t.taken)) {
                todayIndex++;
            }
            
            // Calculate zones first (needed for Best 2 and splash times)
            renderZoneAnalysis();
            
            updateStats();
            renderCalendar();
            
            // Show splash prediction on app open
            showSplashPrediction();
        }).catch(err => {
            // DB Error handled silently
            renderZoneAnalysis();
            updateStats();
            renderCalendar();
        });
        
        // Hamburger menu
        document.getElementById('hamburgerBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const menu = document.getElementById('hamburgerMenu');
            const btn = document.getElementById('hamburgerBtn');
            menu.classList.toggle('open');
            btn.classList.toggle('active');
        });
        
        // Close hamburger menu when clicking outside
        document.addEventListener('click', () => {
            document.getElementById('hamburgerMenu').classList.remove('open');
            document.getElementById('hamburgerBtn').classList.remove('active');
        });
        
        document.getElementById('hamburgerMenu').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Export data
        document.getElementById('exportBtn').addEventListener('click', () => {
            const data = {
                days: days,
                startingBalance: startingBalance,
                exportDate: new Date().toISOString()
            };
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'trading-journal-backup-' + new Date().toISOString().split('T')[0] + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 100);
            document.getElementById('hamburgerMenu').classList.remove('open');
            document.getElementById('hamburgerBtn').classList.remove('active');
        });
        
        // Import data
        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('importFile').click();
        });
        
        document.getElementById('importFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        if (data.days && Array.isArray(data.days)) {
                            // Reset days array
                            days = Array.from({length: 365}, (_, i) => ({ id: i, trades: [] }));
                            // Merge imported days
                            for (let i = 0; i < data.days.length && i < 365; i++) {
                                if (data.days[i] && data.days[i].trades) {
                                    days[i] = data.days[i];
                                }
                            }
                            if (data.startingBalance) startingBalance = data.startingBalance;
                            saveData();
                            updateStats();
                            renderCalendar();
                            alert('Data imported successfully!');
                        } else {
                            alert('Invalid backup file format.');
                        }
                    } catch (err) {
                        alert('Error reading file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
            e.target.value = '';
            document.getElementById('hamburgerMenu').classList.remove('open');
            document.getElementById('hamburgerBtn').classList.remove('active');
        });
    </script>
</body>
</html>
